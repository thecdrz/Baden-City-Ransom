<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Baden City Ransom - AUTHENTIC</title>
  <style>
    body { 
      margin: 0; 
      padding: 0; 
      background: #000; 
      color: #fff; 
      font-family: monospace; 
      overflow: hidden;
    }
    /* Three-band layout: top HUD 10vh, game canvas 80vh, bottom dialogue 10vh */
    #canvasWrap {
      width: 100vw;
      height: 80vh;
      position: relative;
      background: #000; /* canvas sits here */
    }
    #hud {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
  height: 10vh; /* top black bar */
      background: #000;
      color: #fff;
      font-family: 'Courier New', monospace;
  font-size: 28px; /* Increased for better readability */
      font-weight: bold;
      z-index: 1000;
      display: flex;
      align-items: center;
      padding: 0 30px;
      box-sizing: border-box;
      border-bottom: 3px solid #444;
    }
    
    #dialogue {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
  height: 10vh; /* bottom black bar */
      background: #000;
      color: #fff;
      font-family: 'Courier New', monospace;
  font-size: 26px; /* Increased for better readability */
      font-weight: bold;
      z-index: 1000;
      padding: 15px 30px;
      box-sizing: border-box;
      border-top: 3px solid #444;
    }
  </style>
</head>
<body>
  <!-- Top HUD Bar - Player Stats -->
  <div id="hud">
    <div style="display: flex; justify-content: space-between; width: 100%;">
      <div>
        <span style="color: #ffff00;">ALEX</span>
        <span style="margin-left: 20px;">Health: <span id="health">100</span></span>
      </div>
      <div>
        <span>Money: $<span id="money">26.50</span></span>
      </div>
    </div>
  </div>
  
  <!-- Game Canvas Area (80% height) -->
  <div id="canvasWrap"></div>
  
  <!-- Bottom Dialogue Bar - Messages/Chat -->
  <div id="dialogue">
    <div id="dialogue-text">ðŸŽ® BADEN CITY RANSOM - Use Arrow Keys to Move, A to Punch, S to Kick</div>
  </div>

  <script>
  (async function bootstrap() {
    function loadScript(url) {
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = url;
  s.crossOrigin = 'anonymous';
        s.onload = resolve;
        s.onerror = reject;
        document.head.appendChild(s);
      });
    }

    if (!window.Phaser) {
      const statusEl = document.getElementById('dialogue-text');
      const candidates = [
        // Prefer local copies if available
        './phaser.min.js',
        '../vendor/phaser/3.55.2/phaser.min.js',
        '../vendor/phaser/phaser.min.js',
        '/vendor/phaser/3.55.2/phaser.min.js',
        '/vendor/phaser.min.js',
        // CDNs as fallback
        'https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js',
        'https://unpkg.com/phaser@3.55.2/dist/phaser.min.js',
        'https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js'
      ];
      for (const url of candidates) {
        try {
          if (statusEl) statusEl.textContent = `Loading engine: ${url}`;
          await loadScript(url);
          if (window.Phaser) { if (statusEl) statusEl.textContent = `Engine loaded from: ${url}`; break; }
        } catch(e) { /* try next */ }
      }
    }

    if (!window.Phaser) {
      const d = document.getElementById('dialogue-text');
      if (d) d.textContent = 'Failed to load engine. Check connection; CDN may be blocked.';
      return;
    }

    class BadenCityRansomGame extends Phaser.Scene {
      constructor() {
  super({ key: 'BadenCityRansomGame' });
      }
      
      preload() {
        console.log('Loading authentic RCR sprites...');
        // Surface loader diagnostics in the dialogue bar on failures
        this.load.on('loaderror', (file) => {
          const d = document.getElementById('dialogue-text');
          if (d) d.textContent = `Asset failed: ${file?.key || 'unknown'} -> ${file?.src || ''}`;
          console.warn('Load error', file?.key, file?.src);
        });
        this.load.on('progress', (p) => {
          const d = document.getElementById('dialogue-text');
          if (d) d.textContent = `Loading assets: ${(p*100|0)}%`;
        });
        this.load.once('complete', () => {
          const d = document.getElementById('dialogue-text');
          if (d) d.textContent = 'Assets loaded. Initializing scene...';
        });

        const url = (p) => encodeURI(p);
        const logAdd = (kind, key, src) => console.log(`load ${kind}: ${key} <- ${src}`);
        
        // Load sprites with authentic NES frame size (16x24)
        {
          const src = url('../assets/sprites/NES - River City Ransom _ Street Gangs - Playable Characters - Alex.png');
          logAdd('sheet','alex', src);
          this.load.spritesheet('alex', src, {
          frameWidth: 16,
          frameHeight: 32,
          margin: 1,
          spacing: 1
          });
        }
        
  // (Player 2 removed for now)
        
        // Load enemies with matching dimensions
        {
          const src = url('../assets/sprites/NES - River City Ransom _ Street Gangs - Enemies & Bosses - Gang Member - Type 1.png');
          logAdd('sheet','enemy1', src);
          this.load.spritesheet('enemy1', src, {
          frameWidth: 16,
          frameHeight: 32,
          margin: 1,
          spacing: 1
          });
        }
        
        {
          const src = url('../assets/sprites/NES - River City Ransom _ Street Gangs - Enemies & Bosses - Gang Member - Type 2.png');
          logAdd('sheet','enemy2', src);
          this.load.spritesheet('enemy2', src, {
          frameWidth: 16,
          frameHeight: 32,
          margin: 1,
          spacing: 1
          });
        }
        
        {
          const src = url('../assets/sprites/NES - River City Ransom _ Street Gangs - Enemies & Bosses - Gang Member - Type 3.png');
          logAdd('sheet','enemy3', src);
          this.load.spritesheet('enemy3', src, {
          frameWidth: 16,
          frameHeight: 32,
          margin: 1,
          spacing: 1
          });
        }
        // Boss spritesheet (Moose)
        {
          const src = url('../assets/sprites/NES - River City Ransom _ Street Gangs - Enemies & Bosses - Moose.png');
          logAdd('sheet','boss', src);
          this.load.spritesheet('boss', src, {
          frameWidth: 16,
          frameHeight: 32,
          margin: 1,
          spacing: 1
          });
        }
        
        // Load background
        {
          const src = url('../assets/backgrounds/NES - River City Ransom _ Street Gangs - Backgrounds - Downtown.png');
          logAdd('image','downtown', src);
          this.load.image('downtown', src);
        }
        
        // Optional: GandalfHardcore layered character parts (compose into one sprite)
        {
          const base = '../assets/GandalfHardcore FREE Character Asset Pack/GandalfHardcore Character Asset Pack';
          const parts = [
            ['gh_skin', `${base}/Character skin colors/Male Skin3.png`],
            ['gh_pants', `${base}/Male Clothing/Blue Pants.png`],
            ['gh_shirt', `${base}/Male Clothing/Shirt v2.png`],
            ['gh_shoes', `${base}/Male Clothing/Shoes.png`],
            ['gh_hair', `${base}/Male Hair/Male Hair3.png`]
          ];
          parts.forEach(([key, rel]) => { const src = url(rel); logAdd('image', key, src); this.load.image(key, src); });
        }

  // (Knight assets removed)

        // Load authentic River City Ransom music
  this.load.audio('bgm', url('../assets/audio/river_city_ransom_ost_mp3/River City Anthem.mp3'));
  this.load.audio('street_music', url('../assets/audio/river_city_ransom_ost_mp3/Street of No Escape.mp3'));
  this.load.audio('punch_sound', url('../assets/audio/river_city_ransom_ost_mp3/Just For Kicks.mp3'));
      }
      
      create() {
  console.log('Creating authentic Baden City Ransom...');
        const diag = (msg) => { const d = document.getElementById('dialogue-text'); if (d) d.textContent = String(msg); };
        const step = (name) => diag(`Init: ${name}`);
        try {
          step('scene start');
        const canvasWrap = document.getElementById('canvasWrap');
        const getSize = () => {
          const cw = this.scale.width || this.scale.gameSize?.width || canvasWrap?.clientWidth || this.sys.game.config.width || 800;
          const ch = this.scale.height || this.scale.gameSize?.height || canvasWrap?.clientHeight || this.sys.game.config.height || 480;
          return { cw, ch };
        };
        
  // Add background â€“ create CROPPED canvas texture with a safe fallback
  let useKey = 'downtown';
  try {
    const srcTex = this.textures.get('downtown');
    const srcImg = srcTex?.getSourceImage();
    const bgWidth = srcTex?.source?.[0]?.width;
    const bgHeight = srcTex?.source?.[0]?.height;
    if (srcImg && bgWidth && bgHeight) {
      // Crop to keep the actual play area: trim off the sky and bottom credits.
      const CROP_TOP_PCT = 0.72;     // where the playfield starts
      const CROP_BOTTOM_PCT = 0.982; // just before the purple credit strip
      const cropY = Math.floor(bgHeight * CROP_TOP_PCT);
      const cropH = Math.floor(bgHeight * (CROP_BOTTOM_PCT - CROP_TOP_PCT));
      this._bgNaturalW = bgWidth;
      this._bgCropH = cropH > 0 ? cropH : bgHeight; // guard

      const playKey = 'downtown_play';
      if (this.textures.exists(playKey)) this.textures.remove(playKey);
      const playTex = this.textures.createCanvas(playKey, bgWidth, this._bgCropH);
      const ctx = playTex.getContext();
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(srcImg, 0, cropY, bgWidth, this._bgCropH, 0, 0, bgWidth, this._bgCropH);
      playTex.refresh();
      // Detect road (blue) top boundary as a fraction of the cropped texture height
      const analyzeRoadTop = (ctx, w, h) => {
        try {
          const sampleCols = 24;
          const xs = Array.from({length: sampleCols}, (_, i) => Math.floor((i+0.5) * w / sampleCols));
          const isBlueish = (r,g,b) => b > g + 20 && b > r + 20 && b > 80; // strong blue dominance
          for (let y = 0; y < h; y += 2) {
            let blueHits = 0;
            for (const x of xs) {
              const d = ctx.getImageData(x, y, 1, 1).data; // small samples; acceptable at init
              if (isBlueish(d[0], d[1], d[2])) blueHits++;
            }
            if (blueHits >= Math.ceil(sampleCols * 0.6)) {
              return y / h; // fraction from top
            }
          }
        } catch (e) { console.warn('Road detection failed', e); }
        return null;
      };
      const frac = analyzeRoadTop(ctx, bgWidth, this._bgCropH);
      this._roadTopFrac = (frac != null ? frac : 0.65);
      useKey = playKey;
    } else {
      // Fallback to raw image if somethingâ€™s off
      const raw = this.textures.get('downtown');
      this._bgNaturalW = raw?.source?.[0]?.width || 800;
      this._bgCropH = raw?.source?.[0]?.height || 480;
      this._roadTopFrac = 0.65;
    }
  } catch (e) {
    // Fallback to raw image on any unexpected error
    const raw = this.textures.get('downtown');
    this._bgNaturalW = raw?.source?.[0]?.width || 800;
    this._bgCropH = raw?.source?.[0]?.height || 480;
    useKey = 'downtown';
    this._roadTopFrac = 0.65;
  }

  // Use whichever background key we ended up with
  step(`bg add key=${useKey}`);
  if (!this.textures.exists(useKey)) { throw new Error(`Background texture missing: ${useKey}`); }
  this.bg = this.add.image(0, 0, useKey).setOrigin(0, 0);

  // Scale to fill the canvas height (80vh) and center horizontally (robust fallbacks)
  const { cw, ch } = getSize();
  const scale = (this._bgCropH && this._bgCropH > 0) ? (ch / this._bgCropH) : 1;
  this.bg.setScale(scale);
  const displayW = this._bgNaturalW * scale;
  this.bg.x = Math.floor((cw - displayW) / 2);
  this.bg.y = 0;
  this._parallaxX = 0;
        
  // console log for debugging is noisy on some hosts; keep quiet in prod
        
  // Player scale relative to background so pixels match
  const pixelScale = this.bg.scaleX;
  const PLAYER_SCALE_MULT = 1.0; // match background pixel size exactly
  const playerScale = pixelScale * PLAYER_SCALE_MULT;

  // Create Alex player positioned near road (feet-origin at y=ch-18 approx)
  step('spawn alex');
  // Force the classic RCR Alex sheet (no GH composite)
  const PLAYER_TEX = 'alex';
  if (!this.textures.exists(PLAYER_TEX)) throw new Error('Missing player texture: alex');
  this.alex = this.add.sprite(200, ch - 18, PLAYER_TEX, 0).setOrigin(0.5, 1);
    this.alex.setScale(playerScale);
        // If using Knight, normalize to ~32px pixel height so it matches NES scale
        try {
          if (haveKnight && this.textures.exists('kn_idle')) {
            const fh = this.textures.get('kn_idle')?.frames?.[0]?.height || this.textures.get('kn_idle')?.frameTotal && this.textures.get('kn_idle').get(0)?.height || null;
            const srcH = fh || this.textures.get('kn_idle').getSourceImage()?.height || 32;
            const desiredPxH = 32;
            this._playerScaleAdjust = desiredPxH / (srcH || 32);
            const pxScale2 = this.bg.scaleX;
            this.alex.setScale(pxScale2 * (this._playerScaleAdjust || 1.0));
          } else {
            this._playerScaleAdjust = 1.0;
          }
        } catch(e) { this._playerScaleAdjust = 1.0; }
        this.alex.health = 100;
        this.alex.money = 26.50; // Match reference format
        
        // Create enemy gang members
  step('spawn enemies');
  this.enemies = [];
        const enemyTypes = ['enemy1', 'enemy2', 'enemy3'];
        for (let i = 0; i < 3; i++) {
          const enemyType = enemyTypes[i];
          if (this.textures.exists(enemyType)) {
            const enemy = this.add.sprite(500 + i * 80, ch - 18, enemyType, 0).setOrigin(0.5, 1);
            enemy.setScale(playerScale); // Match player scale
            enemy.health = 30;
            enemy.type = enemyType;
            enemy.aiTimer = 0;
            this.enemies.push(enemy);
          }
        }
  // Create Boss (Moose)
  step('spawn boss');
  if (!this.textures.exists('boss')) console.warn('Missing boss texture; skipping boss');
  this.boss = this.textures.exists('boss') ? this.add.sprite(700, ch - 18, 'boss', 0).setOrigin(0.5, 1) : null;
  if (this.boss) { this.boss.setScale(playerScale); this.boss.health = 120; this.boss.type = 'boss'; this.boss.aiTimer = 0; }
        
        // Create Alex animations - basic walk/idle using first few frames
  step('anims');
  this.anims.create({ key: 'alex-idle', frames: [{ key: PLAYER_TEX, frame: 0 }], frameRate: 1, repeat: 0 });
  this.anims.create({ key: 'alex-walk', frames: [{ key: PLAYER_TEX, frame: 0 }, { key: PLAYER_TEX, frame: 1 }], frameRate: 8, repeat: -1 });
  this.anims.create({ key: 'alex-punch', frames: [{ key: PLAYER_TEX, frame: 0, duration: 60 }, { key: PLAYER_TEX, frame: 0, duration: 140 }, { key: PLAYER_TEX, frame: 0, duration: 80 }], repeat: 0 });
  this.anims.create({ key: 'alex-kick', frames: [{ key: PLAYER_TEX, frame: 0, duration: 60 }, { key: PLAYER_TEX, frame: 0, duration: 150 }, { key: PLAYER_TEX, frame: 0, duration: 80 }], repeat: 0 });
  this.anims.create({ key: 'alex-jump', frames: [{ key: PLAYER_TEX, frame: 0 }], frameRate: 6, yoyo: true, repeat: -1 });
        
        // Create enemy animations for each type - simplified
    const enemyAnimTypes = ['enemy1', 'enemy2', 'enemy3'];
  enemyAnimTypes.forEach(enemyType => {
          if (this.textures.exists(enemyType)) {
            this.anims.create({
              key: `${enemyType}-idle`,
              frames: [{ key: enemyType, frame: 0 }],
              frameRate: 1,
              repeat: 0
            });
            
            this.anims.create({
              key: `${enemyType}-walk`,
              frames: [{ key: enemyType, frame: 0 }, { key: enemyType, frame: 1 }],
              frameRate: 6,
              repeat: -1
            });
          }
        });
  // Boss animations
  this.anims.create({ key: 'boss-idle', frames: [{ key: 'boss', frame: 0 }], frameRate: 1, repeat: 0 });
  this.anims.create({ key: 'boss-walk', frames: [{ key: 'boss', frame: 0 }, { key: 'boss', frame: 1 }], frameRate: 6, repeat: -1 });
        
        // Start animations
  this.alex.play('alex-idle');
        this.enemies.forEach(enemy => {
          enemy.play(`${enemy.type}-idle`);
        });
  if (this.boss) this.boss.play('boss-idle');
        
        // Input setup
  step('input');
  this.cursors = this.input.keyboard.createCursorKeys();
        this.keys = this.input.keyboard.addKeys('A,S,D,SPACE');
        
  // Game state
  this.isMoving = false;
  this.isAttacking = false;
  // Lane movement + jump physics (jump height separate from lane Y)
  // Constrain to detected road band; fallback to constant if detection unavailable
  this.ROAD_TOP_PCT = 0.65;
  this.baseYMin = Math.round(ch * (this._roadTopFrac || this.ROAD_TOP_PCT)) + 2; // small cushion
  this.baseYMax = ch - 18;
  this.alexBaseY = this.baseYMax;
  this.alexJumpZ = 0; // negative while rising
  this.alexVy = 0;
  this.GRAVITY = 0.35; // slower fall for clearer airtime
  this.JUMP_VELOCITY = -12.0; // slightly softer takeoff
  this.alex.y = Math.round(this.alexBaseY + this.alexJumpZ);
        
  console.log('Baden City Ransom scene ready. Background cropped to road.');
  // Lightweight on-screen debug overlay (updates on resize)
  const dbg = this.add.text(6, 6, '', { fontFamily: 'monospace', fontSize: '12px', color: '#0f0' }).setDepth(10000);
  const updateDebug = () => {
    const s = [
      `cw:${this.scale.width} ch:${this.scale.height}`,
      `bgKey:${useKey} bgScale:${this.bg.scaleX.toFixed(2)}`,
      `parallax:${Math.round(this._parallaxX)}`,
      `alex:${Math.round(this.alex.x)},${Math.round(this.alex.y)}`
    ].join('  ');
    dbg.setText(s);
  };
  updateDebug();
        
        // Ensure background continues to fit if the canvas size changes
        this.scale.on('resize', (gameSize) => {
          const w = gameSize?.width || this.scale.width || this.scale.gameSize?.width || canvasWrap?.clientWidth || 800;
          const h = gameSize?.height || this.scale.height || this.scale.gameSize?.height || canvasWrap?.clientHeight || 480;
          const scale = h / this._bgCropH;
          this.bg.setScale(scale);
          const displayW = this._bgNaturalW * scale;
          const centerX = Math.floor((w - displayW) / 2);
          this.bg.x = centerX + this._parallaxX;
          this.bg.y = 0;

          // Recompute scales to match pixel size and keep feet on ground
          const pixelScale = this.bg.scaleX;
          const alexScale = pixelScale * (this._playerScaleAdjust || 1.0);
          const enemyScale = pixelScale * 1.0;
          const groundY = h - 18;
          this.alex.setScale(alexScale);
          // update lane bounds and keep lane Y in range; recompute render Y
          this.baseYMax = groundY;
          this.baseYMin = Math.round(h * (this._roadTopFrac || this.ROAD_TOP_PCT)) + 2;
          this.alexBaseY = Phaser.Math.Clamp(this.alexBaseY, this.baseYMin, this.baseYMax);
          if (this.alexJumpZ >= 0) { this.alexJumpZ = 0; this.alexVy = 0; }
          this.alex.y = Math.round(this.alexBaseY + this.alexJumpZ);
          this.enemies.forEach(e=>{ e.setScale(enemyScale); if (e.y > groundY) e.y = groundY; });
          if (this.boss) { this.boss.setScale(enemyScale); if (this.boss.y > groundY) this.boss.y = groundY; }
          updateDebug();
        });
  // Play authentic street music for this outdoor level
  step('music');
        this.sound.stopAll();
        this.music = this.sound.add('street_music', { loop: true, volume: 0.35 });
        const startMusic = () => { if (!this.music.isPlaying) this.music.play(); };
        if (this.sound.locked) {
          this.sound.once('unlocked', startMusic);
          this.input.once('pointerdown', startMusic);
        } else {
          startMusic();
        }
        
        // Function to show messages in dialogue bar
        this.showMessage = (text) => {
          document.getElementById('dialogue-text').innerHTML = text;
        };
        
  this.showMessage('Welcome to Baden City! Fight your way through the gangs!');
  step('ready');
        } catch (err) {
          console.error(err);
          diag(`Init error: ${err?.message || err}`);
          // Do not rethrow to avoid opaque 'Script error.' from cross-origin contexts
          return;
        }
      }
      
      update(time) {
        // Alex movement
        let moving = false;
        const speed = 2;
        
  if (!this.isAttacking && this.cursors.left.isDown) {
          this.alex.x -= speed;
          this.alex.setFlipX(true);
          moving = true;
          this._parallaxX += 0.4; // subtle parallax
  } else if (!this.isAttacking && this.cursors.right.isDown) {
          this.alex.x += speed;
          this.alex.setFlipX(false);
          moving = true;
          this._parallaxX -= 0.4;
        }
        
        // Lane up/down movement along the road
  if (!this.isAttacking && this.cursors.up.isDown) { this.alexBaseY -= speed; moving = true; }
  else if (!this.isAttacking && this.cursors.down.isDown) { this.alexBaseY += speed; moving = true; }
        this.alexBaseY = Phaser.Math.Clamp(this.alexBaseY, this.baseYMin, this.baseYMax);

        // Jump with D if not already airborne
        const onGround = this.alexJumpZ === 0;
  if (!this.isAttacking && Phaser.Input.Keyboard.JustDown(this.keys.D) && onGround) {
          this.alexVy = this.JUMP_VELOCITY;
        }
        // Apply jump gravity to jump height only
        if (!onGround || this.alexVy !== 0) {
          this.alexJumpZ += this.alexVy;
          this.alexVy += this.GRAVITY;
          if (this.alexJumpZ >= 0) { this.alexJumpZ = 0; this.alexVy = 0; }
        }
        // Compose final render Y
        this.alex.y = Math.round(this.alexBaseY + this.alexJumpZ);
        
        // Animation handling
        if (!onGround && !this.isAttacking) {
          if (this.alex.anims.currentAnim?.key !== 'alex-jump') {
            this.alex.play('alex-jump');
          }
        } else if (moving && !this.isAttacking) {
          if (this.alex.anims.currentAnim?.key !== 'alex-walk') {
            this.alex.play('alex-walk');
          }
        } else if (!this.isAttacking) {
          if (this.alex.anims.currentAnim?.key !== 'alex-idle') {
            this.alex.play('alex-idle');
          }
        }
        
        // Combat
        const tryAttack = (kind) => {
          if (this.isAttacking) return;
          this.isAttacking = true;
          this.alex.play(kind === 'kick' ? 'alex-kick' : 'alex-punch');
          // Build a simple hitbox in front of Alex once per press
          const reach = 22;
          const w = 16, h = 18;
          const ox = this.alex.flipX ? -reach : reach;
          const hitRect = new Phaser.Geom.Rectangle(this.alex.x + ox - w/2, this.alex.y - h, w, h);

          const applyHit = (target, dmg, knock=6) => {
            if (!target || !target.active) return;
            const tb = target.getBounds();
            if (Phaser.Geom.Intersects.RectangleToRectangle(hitRect, tb)) {
              target.health = Math.max(0, (target.health||1) - dmg);
              target.setTintFill(0xff0000);
              this.time.delayedCall(80, () => target.clearTint());
              // simple knockback
              target.x += this.alex.flipX ? -knock : knock;
              if (target.health === 0 && !target._defeated) {
                target._defeated = true; target.play(`${target.type||'boss'}-idle`);
                this.tweens.add({ targets: target, alpha: 0, duration: 400, onComplete: () => target.destroy() });
                if (target === this.boss) this.showMessage('Boss defeated!');
              }
            }
          };

          // Damage numbers
          const dmg = kind === 'kick' ? 15 : 10;
          this.enemies.forEach(e => applyHit(e, dmg, 5));
          if (this.boss) applyHit(this.boss, dmg, 8);

          this.alex.once('animationcomplete', () => { this.isAttacking = false; });
        };

        if (Phaser.Input.Keyboard.JustDown(this.keys.A)) { tryAttack('punch'); }
        if (Phaser.Input.Keyboard.JustDown(this.keys.S)) { tryAttack('kick'); }
        
        // Keep Alex on screen (canvas-only area; road fills entire height)
  this.alex.x = Phaser.Math.Clamp(this.alex.x, 50, this.scale.width - 50);

  // Clamp parallax so edges don't leave gaps
  const displayWNow = this._bgNaturalW * this.bg.scaleX;
  const viewW = this.scale.width || this.scale.gameSize?.width || 800;
  const maxOffset = Math.max(0, Math.floor((displayWNow - viewW) / 2));
  this._parallaxX = Phaser.Math.Clamp(this._parallaxX, -maxOffset, maxOffset);
  const centerX = Math.floor((viewW - displayWNow) / 2);
  this.bg.x = centerX + this._parallaxX;
        
  // ... (resize listener moved to create())
        
        // Simple enemy AI
        this.enemies.forEach(enemy => {
          if (time > enemy.aiTimer) {
            // Move towards Alex occasionally
            if (Math.random() < 0.3) {
              if (enemy.x > this.alex.x) {
                enemy.x -= 0.5;
                enemy.setFlipX(true);
              } else {
                enemy.x += 0.5;
                enemy.setFlipX(false);
              }
              
              if (enemy.anims.currentAnim?.key !== `${enemy.type}-walk`) {
                enemy.play(`${enemy.type}-walk`);
              }
            } else {
              if (enemy.anims.currentAnim?.key !== `${enemy.type}-idle`) {
                enemy.play(`${enemy.type}-idle`);
              }
            }
            
            enemy.aiTimer = time + 1000; // Update AI every second
          }
        });
        // Boss AI â€“ steady chase
        if (this.boss && !this.boss._defeated && time > this.boss.aiTimer) {
          const speed = 1.2;
          if (Math.abs(this.boss.x - this.alex.x) > 10) {
            if (this.boss.x > this.alex.x) { this.boss.x -= speed; this.boss.setFlipX(true); }
            else { this.boss.x += speed; this.boss.setFlipX(false); }
            if (this.boss.anims.currentAnim?.key !== 'boss-walk') this.boss.play('boss-walk');
          } else {
            if (this.boss.anims.currentAnim?.key !== 'boss-idle') this.boss.play('boss-idle');
          }
          this.boss.aiTimer = time + 200; // more responsive
        }
        
        // Update HUD elements
        document.getElementById('health').innerHTML = this.alex.health;
        document.getElementById('money').innerHTML = this.alex.money;
      }
    }
    
    // Game configuration with adjusted canvas for bigger UI bars
    const config = {
      type: Phaser.AUTO,
  width: 800,
  height: 480, // 80% of a 600 reference height
  parent: 'canvasWrap',
  backgroundColor: '#000000',
  scene: BadenCityRansomGame,
      render: {
        pixelArt: true,
        antialias: false,
        roundPixels: true
      },
      scale: {
        mode: Phaser.Scale.RESIZE,
        autoCenter: Phaser.Scale.NO_CENTER,
        parent: 'canvasWrap'
      }
    };
    
  console.log('Starting authentic Baden City Ransom...');
    const game = new Phaser.Game(config);
    
    game.events.on('ready', () => {
      console.log('ðŸŽ® BADEN CITY RANSOM IS READY TO PLAY!');
    });
  })();
  </script>
  <script>
    // Catch unexpected runtime errors early and surface them in the dialogue bar
    (function(){
      const report = (msg) => { const d = document.getElementById('dialogue-text'); if (d) d.textContent = String(msg); };
      window.addEventListener('error', (e) => {
        const parts = [
          'Error:', e?.message,
          e?.filename ? `@ ${e.filename}` : '',
          (e?.lineno||e?.colno) ? `:${e.lineno||0}:${e.colno||0}` : ''
        ].filter(Boolean);
        report(parts.join(' '));
        if (e?.error?.stack) console.error(e.error.stack);
      });
      window.addEventListener('unhandledrejection', (e) => {
        const reason = e?.reason;
        report(`Unhandled: ${reason?.message || reason || 'unknown'}`);
        if (reason?.stack) console.error(reason.stack);
      });
    })();
  </script>
</body>
</html>
