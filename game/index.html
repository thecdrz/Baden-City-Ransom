<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Baden City Ransom - AUTHENTIC</title>
  <style>
  html, body { height: 100%; }
  body { 
      margin: 0; 
      padding: 0; 
      background: #000; 
      color: #fff; 
      font-family: monospace; 
      overflow: hidden;
    }
    /* Three-band layout: top HUD 10vh, game canvas 80vh, bottom dialogue 10vh */
    #canvasWrap {
      width: 100%;
      height: 80vh;
      position: relative;
      background: #000; /* canvas sits here */
    }
  #canvasWrap canvas { display:block; }
    #hud {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
  height: 10vh; /* top black bar */
      background: #000;
      color: #fff;
      font-family: 'Courier New', monospace;
  font-size: 28px; /* Increased for better readability */
      font-weight: bold;
      z-index: 1000;
      display: flex;
      align-items: center;
      padding: 0 30px;
      box-sizing: border-box;
      border-bottom: 3px solid #444;
  /* Hidden on title screen; revealed on game start */
  display: none;
    }
    
    #dialogue {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
  height: 10vh; /* bottom black bar */
      background: #000;
      color: #fff;
      font-family: 'Courier New', monospace;
  font-size: 26px; /* Increased for better readability */
      font-weight: bold;
      z-index: 1000;
      padding: 15px 30px;
      box-sizing: border-box;
      border-top: 3px solid #444;
  /* Hidden on title screen; revealed on game start */
  display: none;
    }
  .playerName { color: #ffff00; }
  /* HUD helpers */
  .hudRow { display: flex; justify-content: space-between; width: 100%; }
  .ml20 { margin-left: 20px; }
  /* Wallet HUD polish */
  #moneyWrap { display:inline-flex; position:relative; align-items:center; gap:6px; }
  /* Fixed-width numeric area to prevent HUD jitter when amount changes */
  #moneyValWrap { display:inline-block; position:relative; min-width: 8ch; text-align: right; font-family: monospace; font-variant-numeric: tabular-nums; }
  #money { display:inline-block; }
  .coinIcon { width: 12px; height: 12px; border-radius: 50%;
    background: radial-gradient(circle at 35% 35%, #fff58a 0%, #ffcc00 50%, #e6b300 70%, #7a5200 100%);
    border: 1px solid #5f4a00; box-shadow: 0 0 0 1px #000 inset; image-rendering: pixelated; }
  #moneyWrap.gainFlash { animation: moneyFlash 450ms ease-out; }
  @keyframes moneyFlash { 0% { filter: drop-shadow(0 0 0px #000); transform: scale(1.0);} 50% { filter: drop-shadow(0 0 4px #ffd700); transform: scale(1.05);} 100% { filter:none; transform: scale(1.0);} }
  /* Overlay popup anchored to the right edge of the numeric value */
  .hudGain { position: absolute; right: 0; bottom: 0; color:#ffff66; font-family: monospace; font-size: 12px; text-shadow: 1px 1px 0 #000, -1px 1px 0 #000, 1px -1px 0 #000, -1px -1px 0 #000; opacity: 0; pointer-events: none; }
  .hudGain.show { animation: hudGainRise 800ms ease-out forwards; }
  @keyframes hudGainRise { from { transform: translateY(0); opacity: 1; } to { transform: translateY(-12px); opacity: 0; } }
  /* Dev UI */
  #devBtn { position: fixed; right: 12px; bottom: 12px; z-index: 2000; background:#111; color:#fff; border:1px solid #444; border-radius:8px; padding:8px 10px; opacity:0.7; cursor:pointer; }
  #devBtn:hover { opacity: 1; }
  #devPanel { position: fixed; right: 12px; bottom: 56px; z-index: 2000; background:#111; color:#fff; border:1px solid #444; border-radius:10px; padding:12px; width:240px; display:none; box-shadow: 0 6px 16px rgba(0,0,0,0.35); }
  #devPanel .row { margin-bottom:8px; }
  #devPanel label { display:flex; align-items:center; gap:8px; }
  #devClose { background:#222; color:#fff; border:1px solid #444; border-radius:6px; padding:4px 8px; cursor:pointer; }
  /* Dev UI small helpers */
  .dev-justified { display:flex; justify-content: space-between; width:100%; }
  .dev-grow { flex:1; margin-left:8px; }
  /* Buff HUD */
  #buffs { font-size: 14px; opacity: 0.9; white-space: nowrap; }
  #buffIcons { display:inline-flex; align-items:center; gap:10px; margin-left: 10px; }
  #buffIcons .ico { position: relative; display: inline-flex; align-items:center; justify-content:center; width: 24px; height: 24px; border:1px solid #444; border-radius:5px; background:#111; color:#ffd; font-size: 16px; line-height: 1; box-shadow: 0 0 0 1px #000 inset; }
  #buffIcons .ico .badge { position: absolute; right: -7px; bottom: -7px; background:#222; color:#fff; font-size: 11px; padding: 0 4px; border:1px solid #555; border-radius:7px; transform: scale(0.95); }
  </style>
</head>
<body>
  <!-- Top HUD Bar - Player Stats -->
  <div id="hud">
    <div class="hudRow">
      <div>
  <span class="playerName">TheGuyWho</span>
        <span class="ml20">Health: <span id="health">100</span></span>
      </div>
      <div>
  <span id="moneyWrap"><span class="coinIcon" aria-hidden="true"></span> Money: $<span id="moneyValWrap"><span id="money">4.20</span></span></span>
  <span id="buffs" class="ml20" title="Active buffs"></span>
  <span id="buffIcons" aria-label="Active buff icons"></span>
      </div>
    </div>
  </div>
  
  <!-- Game Canvas Area (80% height) -->
  <div id="canvasWrap"></div>
  
  <!-- Bottom Dialogue Bar - Messages/Chat -->
  <div id="dialogue">
    <div id="dialogue-text">🎮 BADEN CITY RANSOM - Use Arrow Keys to Move, A to Punch, S to Kick</div>
  </div>

  <!-- Dev UI: Toggle panel for quick testing options -->
  <button id="devBtn" aria-controls="devPanel" aria-expanded="false" title="Dev Tools">Dev</button>
  <div id="devPanel" role="dialog" aria-label="Dev Panel">
    <div class="row"><label><input type="checkbox" id="devGod"> Unlimited life</label></div>
    <div class="row"><label><input type="checkbox" id="devBoss"> Spawn boss near player</label></div>
    <div class="row">
      <label class="dev-justified">
        Boss type
        <select id="devBossType" class="dev-grow">
          <option value="boss">Miller (default)</option>
          <option value="boss2">Necro (alt)</option>
        </select>
      </label>
    </div>
  <div class="row"><label><input type="checkbox" id="devHit"> Show hitboxes</label></div>
  <div class="row"><label><input type="checkbox" id="devVerbose"> Verbose logs</label></div>
  <div class="row"><label><input type="checkbox" id="devBossHP"> Show Boss HP</label></div>
  <div class="row">
    <button id="devAddMoney" title="Add $5 to wallet (repeatable)">$+5</button>
  </div>
    <div class="row"><button id="devClose">Close</button></div>
  </div>

  <script>
  (async function bootstrap() {
    function loadScript(url) {
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = url;
  s.crossOrigin = 'anonymous';
        s.onload = resolve;
        s.onerror = reject;
        document.head.appendChild(s);
      });
    }
    // Compute assets base so it works whether served from / (project root) or /game/ (subfolder)
    const ASSETS_BASE = (() => {
      try {
        // location: .../game/index.html -> parent + '/assets'
        const parent = new URL('..', location.href);
        const basePath = parent.pathname.endsWith('/') ? parent.pathname.slice(0, -1) : parent.pathname;
        return `${basePath}/assets`;
      } catch (_) { return '/assets'; }
    })();
    // Fixed URL encoding to handle special characters properly
    const asset = (p) => `${ASSETS_BASE}/${p}`;

    // Lightweight persistent settings (localStorage)
    const SETTINGS_KEY = 'bcr_settings_v1';
    const Settings = {
      load(){ try { return JSON.parse(localStorage.getItem(SETTINGS_KEY)) || {}; } catch(_) { return {}; } },
      save(obj){ try { localStorage.setItem(SETTINGS_KEY, JSON.stringify(obj||{})); } catch(_) {} },
      get(key, def){ const s = this.load(); return (s && s[key] !== undefined) ? s[key] : def; },
      set(key, val){ const s = this.load(); s[key] = val; this.save(s); }
    };
    window._BCRSET = Settings;

  if (!window.Phaser) {
      const statusEl = document.getElementById('dialogue-text');
      const candidates = [
    // Try CDNs first to avoid local 404 noise
    'https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js',
    'https://unpkg.com/phaser@3.55.2/dist/phaser.min.js',
    'https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js',
    // Then local copies if available
    './phaser.min.js',
    '../vendor/phaser/3.55.2/phaser.min.js',
    '../vendor/phaser/phaser.min.js',
    '/vendor/phaser/3.55.2/phaser.min.js',
    '/vendor/phaser.min.js'
      ];
      for (const url of candidates) {
        try {
          if (statusEl) statusEl.textContent = `Loading engine: ${url}`;
          await loadScript(url);
          if (window.Phaser) { if (statusEl) statusEl.textContent = `Engine loaded from: ${url}`; break; }
        } catch(e) { /* try next */ }
      }
    }

    if (!window.Phaser) {
      const d = document.getElementById('dialogue-text');
      if (d) d.textContent = 'Failed to load engine. Check connection; CDN may be blocked.';
      return;
    }

    // Optional Title/Splash Scene
    class TitleScene extends Phaser.Scene {
      constructor(){ super({ key: 'TitleScene' }); }
      preload(){
        // Load start screen music here so it's available before Game scene preloads
        try {
          const asset = (p) => `${ASSETS_BASE}/${p}`;
          this.load.audio('startscreen', asset('audio/river_city_ransom_ost_mp3/startscreen.wav'));
        } catch(_) {}
      }
      create(){
  const { width:w, height:h } = this.scale.gameSize;
  const ENABLE_TITLE_MASK = false; // disable rounded-corner geometry mask by default
  this._allowStart = false;
        // CRT-style overlays
        const makeOverlays = () => {
          try {
            const cw = this.scale.width || w, ch = this.scale.height || h;
            // Destroy previous if exist
            try { this._scan && this._scan.destroy(); this._vig && this._vig.destroy(); } catch(_) {}
            // Scanlines (safe, lightweight)
            const g1 = this.add.graphics();
            g1.fillStyle(0x000000, 0.06);
            for (let y=0; y<ch; y+=2) { g1.fillRect(0, y, cw, 1); }
            g1.setScrollFactor(0).setDepth(2);
            this._scan = g1;
            // Vignette fallback: thick border stroke to darken edges
            const g2 = this.add.graphics();
            g2.lineStyle(Math.max(32, Math.floor(Math.min(cw, ch) * 0.06)), 0x000000, 0.38);
            g2.strokeRect(0, 0, cw, ch);
            g2.setScrollFactor(0).setDepth(3);
            this._vig = g2;
          } catch (e) {
            console.warn('Overlay build skipped:', e);
          }
        };
        // Ensure HUD and dialogue are hidden on the title screen
        try {
          const hud = document.getElementById('hud');
          const dlg = document.getElementById('dialogue');
          if (hud) hud.style.display = 'none';
          if (dlg) dlg.style.display = 'none';
          // Keep canvas at stable 80vh to avoid initial zoom drift
          const wrap = document.getElementById('canvasWrap');
          // Title art: pick the first existing image with minimal 404s
          const assetP = (p) => `${ASSETS_BASE}/${p}`;
          const params = new URLSearchParams(location.search);
          const custom = params.get('titleImg');
          // Prefer known existing root first to avoid 404s
          const picks = [
            custom,
            assetP('BCR-StartScreen2.png'),
            assetP('misc/BCR-StartScreen2.png'),
            assetP('BCR-StartScreen.png'),
            assetP('misc/BCR-StartScreen.png'),
            assetP('misc/BoxArt.png')
          ].filter(Boolean);
          const attach = (imgEl) => {
            const key = 'title_dynamic';
            try { if (this.textures.exists(key)) this.textures.remove(key); } catch(_) {}
            this.textures.addImage(key, imgEl);
            const spr = this.add.image(this.scale.width/2, this.scale.height/2, key).setDepth(1).setOrigin(0.5);
            const fit = () => {
              const cw = this.scale.width, ch = this.scale.height;
              const maxW = cw * 0.9, maxH = ch * 0.75; spr.setScale(1);
              const sx = maxW / spr.width, sy = maxH / spr.height; const s = Math.min(1, sx, sy);
              spr.setScale(s).setPosition(cw/2, ch/2);
            };
            fit(); this.scale.on('resize', fit, this);
            this._titleImg = spr;
            // Fade-in the title art
            try { spr.setAlpha(0); this.tweens.add({ targets: spr, alpha: 1, duration: 800, onComplete: () => {
              // After fully visible, delay then show the prompt and enable start
              this.time.delayedCall(2000, () => { try { if (this._prompt) { this._prompt.setAlpha(1); this._promptBlink && this._promptBlink.resume && this._promptBlink.resume(); } this._allowStart = true; } catch(_) {} });
            }}); } catch(_) {}
          };
          const tryNext = (i=0) => {
            if (i >= picks.length) return; // give up silently
            const url = picks[i];
            const img = new Image();
            img.onload = () => attach(img);
            img.onerror = () => tryNext(i+1);
            img.src = url;
          };
          tryNext(0);
          const prompt = this.add.text(this.scale.width/2, Math.floor(this.scale.height*0.92), 'Press Enter or Click to Start', { fontFamily:'monospace', fontSize:'22px', color:'#ffffff', stroke:'#000', strokeThickness:4 }).setOrigin(0.5).setDepth(4);
          prompt.setAlpha(0);
          // Prepare blinking tween but pause until we reveal prompt
          const blink = this.tweens.add({ targets: prompt, alpha: 0.25, yoyo: true, duration: 800, repeat: -1 });
          try { blink.pause(); } catch(_) {}
          this._prompt = prompt; this._promptBlink = blink;
          // Start screen audio (loop softly) — attempt immediately with unlock retries
          try {
            if (this.sound && !this._started) {
              const savedMute = !!window._BCRSET?.get('musicMute', false);
              const startAud = this.sound.add('startscreen', { loop: true, volume: 0.6, mute: savedMute });
              this._startAud = startAud;
              const playIt = () => { try { this.sound.context?.resume?.(); if (!startAud.isPlaying) startAud.play(); } catch(_) {} };
              if (this.sound.locked) {
                this.sound.once('unlocked', playIt);
                // Aggressively try to resume context a few times in case of silent auto-unlock
                try {
                  let attempts = 8;
                  const tryResume = () => { try { this.sound.context?.resume?.(); playIt(); } catch(_) {} if (--attempts > 0 && this.sound && this.sound.locked) this.time.delayedCall(250, tryResume); };
                  this.time.delayedCall(0, tryResume);
                } catch(_) {}
              } else { playIt(); }
        // Also start on first key press or pointer, to satisfy gesture requirements
        try { this.input.keyboard?.once('keydown', playIt); } catch(_) {}
        try { this.input.once('pointerdown', playIt); } catch(_) {}

              // Allow toggling mute on Title with 'M'
              try {
                this.input.keyboard?.on('keydown-M', () => {
                  const was = !!window._BCRSET?.get('musicMute', false);
                  const now = !was;
                  try { window._BCRSET?.set('musicMute', now); } catch(_) {}
                  try { startAud.setMute(now); } catch(_) {}
                  try { if (this._prompt) this._prompt.setText((this._prompt.text || 'Press Enter or Click to Start') + (now ? ' (M to unmute)' : '')); } catch(_) {}
                });
                // If muted at start, hint on prompt
                if (savedMute) {
                  try { if (this._prompt) this._prompt.setText((this._prompt.text || 'Press Enter or Click to Start') + ' (M to unmute)'); } catch(_) {}
                }
              } catch(_) {}
            }
          } catch(_) {}
          const start = () => {
            if (!this._allowStart) return; // guard until fade+delay have passed
            try { if (this._startAud) { this._startAud.stop(); this._startAud.destroy(); this._startAud = null; } } catch(_) {}
            try { this.scene.start('StoryScene'); } catch(_) { this.scene.start('BadenCityRansomGame'); }
          };
          this.input.on('pointerdown', start);
          try { this.input.keyboard.on('keydown', () => start()); } catch(_) {}
          try {
            // Start on gamepad A (0) or Start (9)
            this.input.gamepad.on('down', (_pad, button, index) => {
              if (index === 0 || index === 9) start();
            });
          } catch(_) {}
          makeOverlays();
        } catch(_) {}
      }
    }

    class StoryScene extends Phaser.Scene {
      constructor(){ super({ key: 'StoryScene' }); }
      create(){
        // Ensure bottom bar visible, HUD hidden
        try {
          const hud = document.getElementById('hud');
          const dlg = document.getElementById('dialogue');
          if (hud) hud.style.display = 'none';
          if (dlg) dlg.style.display = 'block';
        } catch(_) {}

  const textEl = document.getElementById('dialogue-text');
  // Stop any start screen audio if still playing
  try { const a = this.sound.get('startscreen'); if (a) { a.stop(); a.destroy(); } } catch(_) {}
        const pages = [
          'Baden City is slipping under Miller\'s control…',
          'His gang rules the streets. And he\'s coming for TheGuyWho next.',
          'Press Enter to start the fight.'
        ];
        let page = 0; let typing = false; let timer = null; let shown = '';

        const play = (k, vol=0.5, rate=1) => {
          try {
            // Try playing loaded audio key
            if (this.sound && this.sound.keys && this.sound.keys.includes && this.sound.keys.includes(k)) {
              const s = this.sound.add(k, { volume: vol, rate }); s.once('complete', ()=>s.destroy()); s.play();
              return;
            }
            // Fallback: quick oscillator click to mimic typewriter
            const ctx = this.sound?.context;
            if (ctx) {
              const t = ctx.currentTime; const o = ctx.createOscillator(); const g = ctx.createGain();
              o.type = 'square'; o.frequency.setValueAtTime(1400, t);
              g.gain.setValueAtTime(0.0001, t);
              g.gain.linearRampToValueAtTime(Math.min(0.12, vol), t + 0.004);
              g.gain.exponentialRampToValueAtTime(0.0001, t + 0.03);
              o.connect(g).connect(ctx.destination); o.start(t); o.stop(t + 0.04);
            }
          } catch(_) {}
        };
        const typePage = () => {
          if (!textEl) return; typing = true; shown = ''; const full = pages[page] || '';
          const speed = 26; let i = 0; if (timer) timer.remove();
          timer = this.time.addEvent({ delay: speed, loop: true, callback: () => {
            if (i >= full.length) { typing = false; timer.remove(); timer = null; return; }
            shown += full[i++]; textEl.textContent = shown;
            if (i % 2 === 0) play('ui_click', 0.28, 1.0);
          }});
        };
        const next = () => {
          if (typing) { // finish instantly
            const full = pages[page] || ''; typing = false; if (timer) { timer.remove(); timer=null; }
            if (textEl) textEl.textContent = full; return;
          }
          page++;
          if (page < pages.length) { play('ui_advance', 0.35, 1.0); typePage(); }
          else {
            // Start the actual game
            play('ui_advance', 0.4, 1.0);
            this.time.delayedCall(120, () => {
              try { const dlg = document.getElementById('dialogue'); if (dlg) dlg.style.display = 'none'; } catch(_) {}
              this.scene.start('BadenCityRansomGame');
            });
          }
        };

  // Input: Enter / Space / Click to advance (allow multiple clicks)
  this.input.on('pointerdown', next);
        try {
          this.input.keyboard.on('keydown', (ev) => {
            if (ev && (ev.code === 'Enter' || ev.code === 'Space')) next();
          });
        } catch(_) {}

        // Kick off first page
        typePage();
      }
    }

    class BadenCityRansomGame extends Phaser.Scene {
      constructor() {
  super({ key: 'BadenCityRansomGame' });
      }
      
      preload() {
        console.log('Loading authentic RCR sprites...');
        // Surface loader diagnostics in the dialogue bar on failures
        this.load.on('loaderror', (file) => {
          const d = document.getElementById('dialogue-text');
          if (d) d.textContent = `Asset failed: ${file?.key || 'unknown'} -> ${file?.src || ''}`;
          console.warn('Load error', file?.key, file?.src);
        });
        this.load.on('progress', (p) => {
          const d = document.getElementById('dialogue-text');
          if (d) d.textContent = `Loading assets: ${(p*100|0)}%`;
        });
        this.load.once('complete', () => {
          const d = document.getElementById('dialogue-text');
          if (d) d.textContent = 'Assets loaded. Initializing scene...';
          
          // Mark assets as fully loaded
          this.assetsLoaded = true;
          console.log('All game assets loaded successfully');
        });

        const url = (p) => encodeURI(p);
        const logAdd = (kind, key, src) => console.log(`load ${kind}: ${key} <- ${src}`);
        
        // Load player sprites with authentic NES frame size (16x32)
        {
          // Optional: use authentic Ryan sheet if present via ?pc=ryan (keeps key 'alex')
          const pc = new URLSearchParams(location.search).get('pc');
          const useRyan = (pc && pc.toLowerCase() === 'ryan');
          const src = useRyan
            ? asset('sprites/NES - River City Ransom _ Street Gangs - Playable Characters - Ryan.png')
            : asset('sprites/alex_sprite.png');
          logAdd('sheet','alex', src);
          this.load.spritesheet('alex', encodeURI(src), {
          frameWidth: 16,
          frameHeight: 32,
          margin: 1,
          spacing: 1
          });
          try { const d=document.getElementById('dialogue-text'); if (d) d.textContent = useRyan ? 'Loading player: Ryan sheet' : 'Loading player: Alex sheet'; } catch(_) {}
        }

        // New: Load Skeleton Crusader player (PNG sequences) as default player override
        {
          // Use ASSETS_BASE so this works when served from /game/
          const base = `${ASSETS_BASE}/sprites/player-skeleton/Skeleton_Crusader_3/PNG/PNG Sequences`;
          const loadSeq = (folder, count, prefix) => {
            for (let i=0;i<count;i++) {
              const p = `${base}/${folder}/0_Skeleton_Crusader_${folder}_${String(i).padStart(3,'0')}.png`;
              const key = `skele_raw_${prefix}_${i}`;
              if (!this.textures.exists(key)) this.load.image(key, encodeURI(p));
            }
          };
          try {
            loadSeq('Idle', 18, 'idle');
            loadSeq('Walking', 24, 'walk');
            loadSeq('Slashing', 12, 'slash');
            loadSeq('Hurt', 12, 'hurt');
          } catch(_) {}

          // When skeleton frames load, pad to uniform canvas and build alex-* animations
          this.load.once('complete', () => {
            try {
              // Collect loaded keys
              const groups = {
                idle: [], walk: [], slash: [], hurt: []
              };
              Object.keys(this.textures.list).forEach(k=>{
                if (k.startsWith('skele_raw_idle_')) groups.idle.push(k);
                else if (k.startsWith('skele_raw_walk_')) groups.walk.push(k);
                else if (k.startsWith('skele_raw_slash_')) groups.slash.push(k);
                else if (k.startsWith('skele_raw_hurt_')) groups.hurt.push(k);
              });
              // Determine max canvas size
              let maxW=0, maxH=0;
              const all = [...groups.idle, ...groups.walk, ...groups.slash, ...groups.hurt];
              all.forEach(k=>{ try { const img=this.textures.get(k)?.getSourceImage(); if (img){ maxW=Math.max(maxW,img.width||0); maxH=Math.max(maxH,img.height||0);} } catch(_){} });
              maxW = Math.max(maxW, 48); maxH = Math.max(maxH, 48);
              const padKey = (raw) => {
                const out = `${raw}_pad`;
                if (this.textures.exists(out)) return out;
                try {
                  const src = this.textures.get(raw)?.getSourceImage();
                  if (!src) return raw;
                  const t = this.textures.createCanvas(out, maxW, maxH); const c=t.getContext();
                  c.imageSmoothingEnabled=false; c.clearRect(0,0,maxW,maxH);
                  const dx=Math.floor((maxW - src.width)/2), dy=Math.max(0, maxH - src.height);
                  c.drawImage(src, dx, dy);
                  t.refresh();
                  return out;
                } catch(_) { return raw; }
              };
              const buildFrames = (arr) => arr
                .sort((a,b)=>parseInt(a.split('_').pop())-parseInt(b.split('_').pop()))
                // For single-image textures, omit frame to use the base frame (__BASE)
                .map(raw=>({ key: padKey(raw) }));
              const idleF = buildFrames(groups.idle);
              const walkF = buildFrames(groups.walk);
              const slashF = buildFrames(groups.slash);
              const hurtF = buildFrames(groups.hurt);
              if (idleF.length) this._playerTextureKey = idleF[0].key;
              // Remove any previous alex-* anims so we can override cleanly
              ['idle','walk','punch','kick','hurt','jump'].forEach(n=>{ const k=`alex-${n}`; if (this.anims.exists(k)) this.anims.remove(k); });
              // Create smooth, fluid animations mapped to expected keys
              if (idleF.length) this.anims.create({ key:'alex-idle', frames: idleF, frameRate: 6, repeat:-1 });
              // Make feet animate quicker for natural walking
              if (walkF.length) this.anims.create({ key:'alex-walk', frames: walkF, frameRate: 18, repeat:-1 });
              // Build punch/kick without the sword swing; keep sword only for special
              // Punch: 3-frame jab with longer hold on peak pose, plus a small forward lunge handled in attack
              try {
                const p0 = idleF[0] || walkF[0] || slashF[0];
                const p1 = walkF[Math.min(walkF.length-1, Math.max(1, Math.floor(walkF.length*0.55)))] || p0;
                const p2 = walkF[Math.min(walkF.length-1, Math.max(1, Math.floor(walkF.length*0.7)))] || p1;
                // Extra p2 hold for stronger emphasis and slightly slower rate
                this.anims.create({ key:'alex-punch', frames: [p0, p1, p2, p2, p2, p1, p0], frameRate: 20, repeat: 0 });
              } catch(_) {}
              // Kick: later walk frames with longer hold at extension
              try {
                const k0 = walkF[Math.min(walkF.length-1, Math.max(1, Math.floor(walkF.length*0.6)))] || idleF[0] || walkF[0] || slashF[0];
                const k1 = walkF[Math.min(walkF.length-1, Math.max(1, Math.floor(walkF.length*0.85)))] || k0;
                // Extra k1 hold for stronger emphasis and slightly slower rate
                this.anims.create({ key:'alex-kick', frames: [k0, k1, k1, k1, k0], frameRate: 18, repeat: 0 });
              } catch(_) {}
              // Special: actual sword slashing
              if (slashF.length) {
                this.anims.create({ key:'alex-special', frames: slashF, frameRate: 24, repeat:0 });
              }
              // Provide a faster run animation
              if (walkF.length) this.anims.create({ key:'alex-run', frames: walkF, frameRate: 28, repeat:-1 });
              if (hurtF.length) this.anims.create({ key:'alex-hurt', frames: hurtF, frameRate: 16, repeat:0 });
              // No jump frames in pack; emulate with a few fast walk frames for now
              const jumpF = walkF.slice(0, Math.max(1, Math.min(4, walkF.length)));
              if (jumpF.length) this.anims.create({ key:'alex-jump', frames: jumpF, frameRate: 14, repeat:0 });
              this._playerIsSkeleton = true;
            } catch(e) { console.warn('Skeleton player setup failed', e); }
          });
        }
        
  // (Player 2 removed for now)
        
        // Load enemies with matching dimensions
        {
          const src = asset('sprites/enemy1_sprite.png');
          logAdd('sheet','enemy1', src);
          this.load.spritesheet('enemy1', src, {
          frameWidth: 16,
          frameHeight: 32,
          margin: 1,
          spacing: 1
          });
        }
        
        {
          const src = asset('sprites/enemy2_sprite.png');
          logAdd('sheet','enemy2', src);
          this.load.spritesheet('enemy2', src, {
          frameWidth: 16,
          frameHeight: 32,
          margin: 1,
          spacing: 1
          });
        }
        
        {
          const src = asset('sprites/enemy3_sprite.png');
          logAdd('sheet','enemy3', src);
          this.load.spritesheet('enemy3', src, {
          frameWidth: 16,
          frameHeight: 32,
          margin: 1,
          spacing: 1
          });
        }
  // Boss spritesheet (Miller)
        {
          // Use direct path to boss sprite
          const src = asset('sprites/boss_sprite.png');
          logAdd('sheet','boss', src);
          
          // Set specific dimensions for boss sprite
          const bossConfig = {
            frameWidth: 16,
            frameHeight: 32,
            margin: 1,
            spacing: 1
          };
          
          // Load the boss sprite
          this.load.spritesheet('boss', src, bossConfig);
          // Also load raw boss image for robust auto-slicing
          this.load.image('boss_raw', src);
          
          // Add more detailed error/success handling for boss sprite
          this.load.on('filecomplete-spritesheet-boss', (key, type, data) => {
            console.log(`Boss spritesheet loaded successfully: ${key}`, data);
            // Create a backup copy of the texture to ensure it's available
            if (!this.textures.exists('boss_backup') && this.textures.exists('boss')) {
              try {
                this.textures.addImage('boss_backup', this.textures.get('boss').getSourceImage());
                console.log('Created boss_backup texture');
              } catch(e) {
                console.error('Failed to create boss_backup texture', e);
              }
            }
          });
          
          this.load.on('loaderror', (file) => {
            if (file.key === 'boss') {
              console.error('Boss spritesheet failed to load:', file.src);
              document.getElementById('dialogue-text').innerHTML = 'Error loading boss sprite';
            }
          });
        }
        
        // Optional: Gold coin spritesheet (single PNG strip). We'll slice it into frames if present.
        {
          const src = asset('sprites/GoldCoinSpinning.png');
          logAdd('image','coin_src', src);
          this.load.image('coin_src', src);
          this.load.once('complete', () => {
            try {
              if (!this.textures.exists('coin_src')) return;
              const img = this.textures.get('coin_src')?.getSourceImage();
              const iw = img?.width|0, ih = img?.height|0;
              if (!iw || !ih) return;
              let frames = 0, fw = 0, fh = 0, horiz = true;
              if (iw >= ih && iw % ih === 0) { frames = iw/ih; fw = ih; fh = ih; horiz = true; }
              else if (ih > iw && ih % iw === 0) { frames = ih/iw; fw = iw; fh = iw; horiz = false; }
              if (frames >= 2 && frames <= 64) {
                const keys = [];
                for (let i=0; i<frames; i++) {
                  const key = `coin_png_${i}`;
                  if (!this.textures.exists(key)) {
                    const t = this.textures.createCanvas(key, fw, fh);
                    const c = t.getContext(); c.imageSmoothingEnabled=false; c.clearRect(0,0,fw,fh);
                    const sx = horiz ? (i*fw) : 0;
                    const sy = horiz ? 0 : (i*fh);
                    c.drawImage(img, sx, sy, fw, fh, 0, 0, fw, fh);
                    t.refresh();
                  }
                  keys.push(key);
                }
                // Prefer this animation over fallback; replace if exists
                if (this.anims.exists('coin-spin')) this.anims.remove('coin-spin');
                this.anims.create({ key: 'coin-spin', frames: keys.map(k=>({ key:k })), frameRate: 16, repeat: -1 });
                this._coinAnimReady = true;
              }
            } catch(_) {}
          });
        }

        // Load background
        {
          const src = asset('backgrounds/downtown_bg.png');
          logAdd('image','downtown', src);
          this.load.image('downtown', src);
        }
        // Load Baden Cemetery layered assets only if explicitly requested (?map=cemetery)
        try {
          const mapParam = (new URLSearchParams(location.search).get('map') || '').toLowerCase();
          if (mapParam === 'cemetery' || mapParam === 'cem') {
            const cem = (rel) => asset(`BadenCemetery/${rel}`);
            this.load.image('cem_bg0', cem('Background_0.png'));
            this.load.image('cem_bg1', cem('Background_1.png'));
            this.load.image('cem_grass1', cem('Grass_background_1.png'));
            this.load.image('cem_grass2', cem('Grass_background_2.png'));
            this.load.image('cem_tiles', cem('Tiles.png'));
            this.load.image('cem_brush', cem('brush.png'));
            this.load.image('cem_salt', cem('Salt.png'));
          }
        } catch(_) {}
        
        // Optional: GandalfHardcore layered character parts (compose into one sprite)
        // Disabled by default to avoid 404s if the pack isn't present; enable with ?gh=1
        {
          const enableGH = new URLSearchParams(location.search).get('gh') === '1';
          if (enableGH) {
            const base = `${ASSETS_BASE}/GandalfHardcore FREE Character Asset Pack/GandalfHardcore Character Asset Pack`;
            const parts = [
              ['gh_skin', `${base}/Character skin colors/Male Skin3.png`],
              ['gh_pants', `${base}/Male Clothing/Blue Pants.png`],
              ['gh_shirt', `${base}/Male Clothing/Shirt v2.png`],
              ['gh_shoes', `${base}/Male Clothing/Shoes.png`],
              ['gh_hair', `${base}/Male Hair/Male Hair3.png`]
            ];
            parts.forEach(([key, rel]) => { const src = url(rel); logAdd('image', key, src); this.load.image(key, src); });
          } else {
            console.log('Skipping optional GH layered parts (add ?gh=1 to enable)');
          }
        }

  // (Knight assets removed)

        // Load authentic River City Ransom music
  this.load.audio('bgm', asset('audio/river_city_ransom_ost_mp3/bgm_anthem.mp3'));
  this.load.audio('street_music', asset('audio/river_city_ransom_ost_mp3/bgm_street.mp3'));
  // New preferred track for the level
  try { this.load.audio('contemplation', asset('audio/river_city_ransom_ost_mp3/contemplation.ogg')); } catch(_) {}
  // Start screen SFX (path corrected; TitleScene also preloads this so it's ready earlier)
  try { this.load.audio('startscreen', asset('audio/river_city_ransom_ost_mp3/startscreen.wav')); } catch(_) {}
  // Short SFX
  this.load.audio('sfx_punch1', asset('audio/river_city_ransom_ost_mp3/sfx_punch1.mp3'));
  this.load.audio('sfx_punch2', asset('audio/river_city_ransom_ost_mp3/sfx_punch2.mp3'));
  this.load.audio('sfx_jump1',  asset('audio/river_city_ransom_ost_mp3/sfx_jump1.mp3'));
  this.load.audio('sfx_jump2',  asset('audio/river_city_ransom_ost_mp3/sfx_jump2.mp3'));
  // Shop exteriors and interior
  try {
    this.load.image('shop_ext_grocery', asset('sprites/shops/Grocery shop.png'));
    this.load.image('shop_ext_electronics', asset('sprites/shops/Electronics Shop.png'));
    this.load.image('shop_ext_icecream', asset('sprites/shops/Ice Cream Shop.png'));
  } catch(_) {}
      }
      
      create() {
  console.log('=== CREATING BADEN CITY RANSOM GAME ===');
  console.log('Scene started, adding basic test elements...');
  
  // Add a simple test rectangle to verify scene is working
  try {
  // (removed temporary red test rectangle)
  } catch(e) {
    console.error('Failed to add test rectangle:', e);
  }
  
  // Basic scene verification
  console.log('Scene key:', this.scene.key);
  console.log('Available textures:', this.textures.getTextureKeys());
  
  // Verify critical textures exist (but don't block creation)
  const requiredTextures = ['alex', 'downtown'];
  const missing = requiredTextures.filter(tex => !this.textures.exists(tex));
  if (missing.length > 0) {
    console.warn('Some textures missing:', missing);
    // Continue anyway with fallbacks
  }
  
  // Ensure camera zoom is neutral (avoid accidental device zoom factors)
  try { this.cameras.main.setZoom(1); } catch(_) {}
  console.log('Initial setup complete, proceeding with scene creation...');
        // Reveal HUD and dialogue now that gameplay begins
        try {
          const hud = document.getElementById('hud');
          const dlg = document.getElementById('dialogue');
          if (hud) hud.style.display = 'flex';
          if (dlg) dlg.style.display = 'block';
        } catch(_) {}
        const diag = (msg) => { const d = document.getElementById('dialogue-text'); if (d) d.textContent = String(msg); };
        const step = (name) => diag(`Init: ${name}`);
        try {
          step('scene start');
        const canvasWrap = document.getElementById('canvasWrap');
        const getSize = () => {
          const cw = this.scale.width || this.scale.gameSize?.width || canvasWrap?.clientWidth || this.sys.game.config.width || 800;
          const ch = this.scale.height || this.scale.gameSize?.height || canvasWrap?.clientHeight || this.sys.game.config.height || 480;
          return { cw, ch };
        };
        // Choose map (default to downtown); supports ?map=cemetery to try cemetery
        try {
          const m = new URLSearchParams(location.search).get('map');
          this.mapName = (m ? m : 'downtown').toLowerCase();
          this.cemeteryActive = (this.mapName === 'cemetery' || this.mapName === 'cem');
        } catch(_) { this.mapName = 'downtown'; this.cemeteryActive = false; }

        // Cemetery helpers
        this._recomputeTerrainGates = () => {
          try {
            const scaleX = this.bg?.scaleX || 1;
            this._terrainGates = (this._terrainGatesRaw||[]).map(g => ({ start: g.start * scaleX, end: g.end * scaleX, minJump: g.minJump||-6 }));
          } catch(_) {}
        };
        this._applyTerrainGates = (prevX) => {
          try {
            if (!this._terrainGates || !this._terrainGates.length) return;
            const airborne = (this.alexJumpZ < -6); // require modest jump height
            if (airborne) return; // freely pass while airborne
            const x = this.alex?.x || 0;
            for (const g of this._terrainGates) {
              if (prevX < g.start && x >= g.start) { this.alex.x = g.start - 1; break; }
              if (prevX > g.end && x <= g.end) { this.alex.x = g.end + 1; break; }
            }
          } catch(_) {}
        };
        this._updateCemeteryParallax = () => {
          try {
            if (!this.cemeteryActive || !this.cemParallax) return;
            const camX = this.cameras?.main?.scrollX || 0;
            this.cemParallax.far0 && (this.cemParallax.far0.tilePositionX = camX * 0.20);
            this.cemParallax.far1 && (this.cemParallax.far1.tilePositionX = camX * 0.35);
            this.cemParallax.near && (this.cemParallax.near.tilePositionX = camX * 0.80);
          } catch(_) {}
        };
        this._updateCemeteryOnResize = (w, h) => {
          try {
            if (!this.cemeteryActive) return;
            // TileSprites are screen-space; resize them to fill the view
            if (this.cemParallax) {
              ['far0','far1','near'].forEach(k => { const ts = this.cemParallax[k]; if (ts) { ts.width = w; ts.height = h; ts.setSize(w,h); } });
            }
            // Gates depend on scale; recompute
            this._recomputeTerrainGates && this._recomputeTerrainGates();
          } catch(_) {}
        };
  // Centralized resize application to keep math consistent
        const applyResize = (w, h) => {
          if (!w || !h) { const s = getSize(); w = s.cw; h = s.ch; }
          const scale = h / (this._bgCropH || h);
          if (this.bg) {
            this.bg.setScale(scale);
            const displayW = (this._bgNaturalW || w) * scale;
            this.bg.x = 0;
            this.bg.y = 0;
            this.cameras.main.setBounds(0, 0, displayW, h);
          }
          // Recompute scales to match pixel size and keep feet on ground
          const pixelScale = this.bg?.scaleX || 1;
          const alexScale = pixelScale * (this._playerScaleAdjust || 1.0);
          const enemyScale = pixelScale * 1.0;
          const roadTop = Math.round(h * (this._roadTopFrac || this.ROAD_TOP_PCT));
          const roadBot = Math.round(h * (this._roadBottomFrac || 0.96));
          // Allow a tiny safety margin so feet can touch the very last blue row
          const groundY = Math.min(h - 1, roadBot + 2);
          // Guarantee a minimum vertical lane size for up/down movement, anchored at ground line
          const laneMax = groundY;
          const minLane = Math.max(56, Math.floor(h * 0.12));
          let laneMin = roadTop; // include the very first blue row
          if ((laneMax - laneMin) < minLane) {
            laneMin = Math.max(roadTop + 6, laneMax - minLane);
          }
          if (this.alex) {
            this.alex.setScale(alexScale);
          }
          this.baseYMax = laneMax;
          // Keep player constrained to the detected or widened road band
          this.baseYMin = laneMin;
          this.alexBaseY = Phaser.Math.Clamp(this.alexBaseY, this.baseYMin, this.baseYMax);
          if (this.alexJumpZ >= 0) { this.alexJumpZ = 0; this.alexVy = 0; }
          if (this.alex) this.alex.y = Math.round(this.alexBaseY + this.alexJumpZ);
          (this.enemies||[]).forEach(e=>{ e.setScale(enemyScale); if (e.y > groundY) e.y = groundY; });
          if (this.boss) {
            const bossAdj = (this.bossAnimPrefix === 'boss2') ? (this._currentBossScaleAdj || 1.0) : 1.0;
            this.boss.setScale(enemyScale * bossAdj);
            // Recompute scaled foot padding (if Necro) and pin feet to road
            try {
              if (this.bossAnimPrefix === 'boss2') {
                const raw = (this.boss._footPadRaw || this._necroFootPadPx || 0);
                this.boss._footPadScaled = Math.round(raw * (this.boss.scaleY || 1));
                const bias = this.feetBiasFor(this.boss,'boss');
                this.boss.y = Math.round(this.alexBaseY + (this.boss._footPadScaled || 0) + bias);
              } else {
                if (this.boss.y > groundY) this.boss.y = groundY;
              }
            } catch(_) { if (this.boss.y > groundY) this.boss.y = groundY; }
          }
          // Position shop door(s) (if present) at the far (top) side of the road
          try {
            if (this.shopDoors && this.shopDoors.length) {
              const scaleX = this.bg?.scaleX || 1;
              // Door height approx same scale as player; fallback to a fraction of screen height
              const alexH = Math.max(32, Math.floor((this.alex?.displayHeight || 0)));
              // Make doors 25% taller and 50% wider than previous sizing
              const baseH = (alexH ? Math.floor(alexH * 1.15) : Math.floor(h * 0.24));
              const doorH = Math.max(48, Math.floor(baseH * 1.25));
              const doorW = Math.floor((doorH * 0.70) * 1.5); // previous width * 1.5
              this.shopDoors.forEach(door => {
                const xWorld = door._shopRef?.x || 260;
                door.setDisplaySize(doorW, doorH);
                door.x = Math.floor(xWorld * scaleX);
                // Anchor to top side (roadTop)
                door.y = Math.floor(roadTop);
                door.setOrigin(0.5, 1);
                // Always render behind the player so Alex never appears behind the door sprite
                door.setDepth(-100);
                // Expand the interact radius to match visual width
                try { if (door._shopRef) door._shopRef.radius = Math.max(door._shopRef.radius||0, Math.round(doorW * 0.6)); } catch(_) {}
              });
            }
            // Place prompt just above the top road line
            try {
              if (this.shop?.prompt) {
                this.shop.prompt.y = Math.max(12, Math.floor(roadTop - 10));
              }
            } catch(_) {}
          } catch(_) {}
          // Cemetery-specific resize updates
          try { if (this.cemeteryActive) { const s = getSize(); this._updateCemeteryOnResize && this._updateCemeteryOnResize(s.cw, s.ch); } } catch(_) {}
        };
        
  // Build background depending on selected map
  if (this.cemeteryActive) {
    // Cemetery: parallax layers + long ground strip
    step('bg add cemetery');
    try {
      const g1 = this.textures.get('cem_grass1')?.getSourceImage();
      if (!g1) throw new Error('cem_grass1 missing');
      const { cw, ch } = getSize();
      const tileW = g1.width || 512;
      const tileH = g1.height || ch;
  // Crop out the heavy canopy to keep the path/road visible
  // Pick the middle band of the source so the path/road is visible (avoid sky and deep canopy)
  const CEM_CROP_TOP_PCT = 0.38;   // start ~38% from top
  const CEM_CROP_BOTTOM_PCT = 0.97; // keep down to ~97%
  const cropY = Math.floor(tileH * CEM_CROP_TOP_PCT);
  const cropH = Math.max(8, Math.floor(tileH * (CEM_CROP_BOTTOM_PCT - CEM_CROP_TOP_PCT)));
  this._bgCropH = cropH;
      // World width targeting ~3 minutes walk at base speed
      const pxPerSec = 120; const targetSecs = 180;
      const scaleForBand = ch / tileH;
      const targetWorldWidth = pxPerSec * targetSecs;
      const tilesNeeded = Math.ceil(targetWorldWidth / (tileW * scaleForBand));
      const TILES = Math.max(3, Math.min(40, tilesNeeded));
      const longKey = 'cem_long';
      if (this.textures.exists(longKey)) this.textures.remove(longKey);
      const longTex = this.textures.createCanvas(longKey, tileW * TILES, cropH);
      const lctx = longTex.getContext(); lctx.imageSmoothingEnabled = false;
      for (let i=0;i<TILES;i++) {
        // Draw the cropped lower slice so trees don't block the lane
        lctx.drawImage(g1, 0, cropY, tileW, cropH, i*tileW, 0, tileW, cropH);
      }
      longTex.refresh();
      this._bgNaturalW = tileW * TILES;
  // Road band within the cropped strip (middle-lower portion)
  this._roadTopFrac = 0.64; this._roadBottomFrac = 0.96;
  // Base ground image (acts as world bounds anchor)
  this.bg = this.add.image(0, 0, longKey).setOrigin(0, 0);
  this._bgKey = longKey;
      const scale = ch / cropH; this.bg.setScale(scale);
      const displayW = this._bgNaturalW * scale;
      const cam = this.cameras.main; cam.setRoundPixels(true); cam.setBounds(0, 0, displayW, ch);
      // Parallax layers in screen-space using tileSprites
      this.cemParallax = this.cemParallax || {};
      const mkTs = (key, depth, y=0, h=ch) => this.add.tileSprite(0,y,cw,h,key).setOrigin(0,0).setScrollFactor(0).setDepth(depth);
      try { if (this.textures.exists('cem_bg0')) this.cemParallax.far0 = mkTs('cem_bg0', -3000); } catch(_) {}
      // Disable mid BG1 to avoid duplicated houses if grass1 already includes them
      // try { if (this.textures.exists('cem_bg1')) this.cemParallax.far1 = mkTs('cem_bg1', -2500); } catch(_) {}
      // Limit near foliage to the upper portion so it won't cover the road
      try {
        if (this.textures.exists('cem_grass2')) {
          const nearH = Math.floor(ch * 0.35); // only top third so it never covers the road
          this.cemParallax.near = mkTs('cem_grass2', -50, 0, nearH);
          this.cemParallax.near.setAlpha(0.90);
        }
      } catch(_) {}
      this._updateCemeteryParallax && this._updateCemeteryParallax();
      // Create periodic low mounds that require a jump to cross
      this._terrainGatesRaw = [];
      for (let i=1; i<TILES; i+=2) {
        const start = i * tileW + Math.floor(tileW * 0.42);
        const width = Math.floor(tileW * 0.16);
        this._terrainGatesRaw.push({ start, end: start + width, minJump: -6 });
      }
      this._recomputeTerrainGates && this._recomputeTerrainGates();
    } catch(e) {
      console.warn('Cemetery build failed, falling back to downtown:', e?.message||e);
      this.cemeteryActive = false; this.mapName = 'downtown';
    }
  }
  if (!this.cemeteryActive) {
    // Downtown classic background flow
    let useKey = 'downtown';
    console.log('Starting background creation...');
    try {
      const srcTex = this.textures.get('downtown');
      const srcImg = srcTex?.getSourceImage();
      const bgWidth = srcTex?.source?.[0]?.width;
      const bgHeight = srcTex?.source?.[0]?.height;
      if (srcImg && bgWidth && bgHeight) {
        // Crop to keep the actual play area: trim off the sky and bottom credits.
        const CROP_TOP_PCT = 0.72;     // where the playfield starts
        const CROP_BOTTOM_PCT = 0.978; // crop a touch higher to fully remove the purple credit strip
        const cropY = Math.floor(bgHeight * CROP_TOP_PCT);
        const cropH = Math.floor(bgHeight * (CROP_BOTTOM_PCT - CROP_TOP_PCT));
        this._bgNaturalW = bgWidth;
        this._bgCropH = cropH > 0 ? cropH : bgHeight; // guard
        const playKey = 'downtown_play';
        if (this.textures.exists(playKey)) this.textures.remove(playKey);
        const playTex = this.textures.createCanvas(playKey, bgWidth, this._bgCropH);
        const ctx = playTex.getContext();
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(srcImg, 0, cropY, bgWidth, this._bgCropH, 0, 0, bgWidth, this._bgCropH);
        playTex.refresh();
        // Blue road band detection
        const analyzeRoadTop = (ctx, w, h) => {
          try {
            const sampleCols = 24;
            const xs = Array.from({length: sampleCols}, (_, i) => Math.floor((i+0.5) * w / sampleCols));
            const isBlueish = (r,g,b) => b > g + 20 && b > r + 20 && b > 80;
            for (let y = 0; y < h; y += 2) {
              let blueHits = 0;
              for (const x of xs) { const d = ctx.getImageData(x, y, 1, 1).data; if (isBlueish(d[0], d[1], d[2])) blueHits++; }
              if (blueHits >= Math.ceil(sampleCols * 0.6)) return y / h;
            }
          } catch(e) {}
          return null;
        };
        const analyzeRoadBottom = (ctx, w, h) => {
          try {
            const sampleCols = 24;
            const xs = Array.from({length: sampleCols}, (_, i) => Math.floor((i+0.5) * w / sampleCols));
            const isBlueish = (r,g,b) => b > g + 12 && b > r + 12 && b > 48;
            for (let y = h - 1; y >= 0; y -= 2) {
              let blueHits = 0;
              for (const x of xs) { const d = ctx.getImageData(x, y, 1, 1).data; if (isBlueish(d[0], d[1], d[2])) blueHits++; }
              if (blueHits >= Math.ceil(sampleCols * 0.35)) return y / h;
            }
          } catch(e) {}
          return null;
        };
        const fracTop = analyzeRoadTop(ctx, bgWidth, this._bgCropH);
        const fracBot = analyzeRoadBottom(ctx, bgWidth, this._bgCropH);
        this._roadTopFrac = (fracTop != null ? fracTop : 0.65);
        this._roadBottomFrac = (fracBot != null ? fracBot : 0.96);
        useKey = playKey;
      } else {
        const raw = this.textures.get('downtown');
        this._bgNaturalW = raw?.source?.[0]?.width || 800;
        this._bgCropH = raw?.source?.[0]?.height || 480;
        this._roadTopFrac = 0.65;
        this._roadBottomFrac = 0.96;
      }
    } catch (e) {
      const raw = this.textures.get('downtown');
      this._bgNaturalW = raw?.source?.[0]?.width || 800;
      this._bgCropH = raw?.source?.[0]?.height || 480;
      useKey = 'downtown';
      this._roadTopFrac = 0.65;
      this._roadBottomFrac = 0.96;
    }
    try {
      if (this.textures.exists('downtown_play')) {
        const src = this.textures.get('downtown_play').getSourceImage();
        const tileW = this._bgNaturalW;
        const tileH = this._bgCropH;
        const { ch } = getSize();
        const scaleForBand = ch / tileH;
        const pxPerSec = 120; const targetSecs = 180;
        const targetWorldWidth = pxPerSec * targetSecs;
        const tilesNeeded = Math.ceil(targetWorldWidth / (tileW * scaleForBand));
        const TILES = Math.max(3, Math.min(40, tilesNeeded));
        const longKey = 'downtown_long';
        if (this.textures.exists(longKey)) this.textures.remove(longKey);
        const longTex = this.textures.createCanvas(longKey, tileW * TILES, tileH);
        const lctx = longTex.getContext(); lctx.imageSmoothingEnabled = false;
        for (let i=0;i<TILES;i++) lctx.drawImage(src, 0, 0, tileW, tileH, i*tileW, 0, tileW, tileH);
        longTex.refresh();
        useKey = longKey; this._bgNaturalW = tileW * TILES;
      }
    } catch(e) { console.warn('Failed to build long background, using single tile', e); }
  step(`bg add key=${useKey}`);
    if (!this.textures.exists(useKey)) { throw new Error(`Background texture missing: ${useKey}`); }
  this.bg = this.add.image(0, 0, useKey).setOrigin(0, 0);
  this._bgKey = useKey;
    const { cw, ch } = getSize();
    const scale = (this._bgCropH && this._bgCropH > 0) ? (ch / this._bgCropH) : 1;
    this.bg.setScale(scale);
    const displayW = this._bgNaturalW * scale; this.bg.x = 0; this.bg.y = 0;
    const cam = this.cameras.main; cam.setRoundPixels(true); cam.setBounds(0, 0, displayW, ch);
  }
        
  // console log for debugging is noisy on some hosts; keep quiet in prod
        
  // Player scale relative to background so pixels match
  const pixelScale = this.bg.scaleX;
  const PLAYER_SCALE_MULT = 1.0; // match background pixel size exactly
  const playerScale = pixelScale * PLAYER_SCALE_MULT;

  // Build an animated coin (pixel-art) if not present
  try {
    const makeFrame = (key, w, h, variant) => {
      const t = this.textures.createCanvas(key, w, h);
      const ctx = t.getContext();
      ctx.imageSmoothingEnabled = false;
      ctx.clearRect(0,0,w,h);
      // Colors
      const rim = '#7a5200';
      const fill = '#ffcc00';
      const hi = '#fff58a';
      const mid = '#e6b300';
      // Draw depending on variant (0: full, 1: mid, 2: thin, 3: mid)
      if (variant === 0) {
        // Full coin: 12x12 canvas footprint
        // Outer rim
        ctx.fillStyle = rim; ctx.fillRect(3,1,6,10);
        // Inner body
        ctx.fillStyle = fill; ctx.fillRect(4,2,4,8);
        // Highlight
        ctx.fillStyle = hi; ctx.fillRect(4,2,2,2);
        // Subtle face mark
        ctx.fillStyle = mid; ctx.fillRect(5,6,2,1);
      } else if (variant === 1 || variant === 3) {
        // Mid tilt (narrower width)
        ctx.fillStyle = rim; ctx.fillRect(4,1,4,10);
        ctx.fillStyle = fill; ctx.fillRect(5,2,2,8);
        ctx.fillStyle = hi;  ctx.fillRect(5,2,1,2);
        ctx.fillStyle = mid; ctx.fillRect(5,6,1,1);
      } else if (variant === 2) {
        // Edge-on thin glint
        ctx.fillStyle = rim; ctx.fillRect(5,1,2,10);
        ctx.fillStyle = fill; ctx.fillRect(6,2,1,8);
        ctx.fillStyle = hi;  ctx.fillRect(6,2,1,2);
      }
      t.refresh();
    };
    const baseKey = 'coin_spin_';
    const frameW = 12, frameH = 12;
    const keys = [0,1,2,3].map(i => `${baseKey}${i}`);
    if (!this.textures.exists(keys[0])) {
      keys.forEach((k,i)=> makeFrame(k, frameW, frameH, i));
    }
    if (!this.anims.exists('coin-spin')) {
      this.anims.create({ key: 'coin-spin', frames: keys.map(k=>({ key:k })), frameRate: 12, repeat: -1 });
    }
  } catch(_) {}

  // Create Alex/Skeleton player positioned near road (feet-origin at y=ch-18 approx)
  step('spawn alex');
  // Force the classic RCR Alex sheet (no GH composite)
  // Enhanced player creation with texture verification
  const PLAYER_TEX = this._playerTextureKey || 'alex';
  // Ensure current height available regardless of which background branch executed
  const { ch } = getSize();
  
  // Create player sprite with better error handling
  try {
  if (this.textures.exists(PLAYER_TEX)) {
      // For image-based textures (skeleton frames), don't pass a numeric frame
      this.alex = this.add.sprite(200, ch - 18, PLAYER_TEX).setOrigin(0.5, 1);
      console.log('Alex sprite created successfully');
    } else {
      console.warn('Alex texture missing, creating simple fallback');
      // Create a simple canvas texture as fallback
      const fallbackCanvas = this.textures.createCanvas('alex_fallback', 16, 32);
      const ctx = fallbackCanvas.getContext();
      ctx.fillStyle = '#4444ff';
      ctx.fillRect(0, 0, 16, 32);
      fallbackCanvas.refresh();
      
      this.alex = this.add.sprite(200, ch - 18, 'alex_fallback', 0).setOrigin(0.5, 1);
      console.log('Alex fallback sprite created');
      try { const d=document.getElementById('dialogue-text'); if (d) d.textContent = 'Player spritesheet missing; blue placeholder in use.'; } catch(_) {}
    }
  } catch(e) {
    console.error('Failed to create Alex sprite:', e);
    // Last resort: create a simple rectangle shape
    this.alex = this.add.rectangle(200, ch - 18, 16, 32, 0x4444ff).setOrigin(0.5, 1);
    console.log('Created rectangle fallback for Alex');
    try { const d=document.getElementById('dialogue-text'); if (d) d.textContent = 'Player failed to load; blue placeholder active.'; } catch(_) {}
  }
  // Adjust scale: if using skeleton PNGs, compute a world-space scale adjust and apply pixelScale separately
  if (this._playerIsSkeleton) {
    try {
      const f = this.textures.getFrame(PLAYER_TEX, 0) || { cutHeight: this.textures.get(PLAYER_TEX)?.getSourceImage()?.height };
    const srcH = Math.max(1, f?.cutHeight || f?.height || 128);
  const targetWorldH = 31; // desired height in background pixels (~10% larger)
      const adj = Phaser.Math.Clamp(targetWorldH / srcH, 0.02, 1.0);
      this._playerScaleAdjust = adj;
      // Apply initial scale using current pixelScale; resize will maintain: alexScale = pixelScale * _playerScaleAdjust
      this.alex.setScale(playerScale * adj);
    } catch(_) { this.alex.setScale(playerScale); }
  } else {
    this.alex.setScale(playerScale);
  }
  // Camera follows the player for smooth scrolling
  this.cameras.main.startFollow(this.alex, true, 1, 1);
  // Ensure camera is centered on spawn so the player is on-screen
  try { this.cameras.main.centerOn(this.alex.x, this.alex.y); } catch(_) {}
  // Keep previously computed scale adjust (for skeleton image-based player)
        this.alex.health = 100;
  this.alex.money = 4.20; // New default
        
        // Create diverse enemy gang members from available sprites
  step('spawn enemies');
  this.enemies = [];
        // Compute display width safely for spawn placement
        const displayW = Math.max(1, ((this._bgNaturalW||800) * (this.bg?.scaleX||1)));
        
        // Enhanced enemy spawning with variety and different stats
        const enemyConfigs = [
          { type: 'enemy1', health: 50, speed: 1.1, cadence: 800, name: 'Street Punk' },
          { type: 'enemy2', health: 70, speed: 0.8, cadence: 1200, name: 'Heavy Bruiser' },
          { type: 'enemy3', health: 60, speed: 1.0, cadence: 900, name: 'Gang Member' }
        ];
        
        // Spawn 2-3 enemies with different types for variety
        const numEnemies = Math.min(2 + Math.floor(Math.random() * 2), enemyConfigs.length);
        const usedConfigs = enemyConfigs.slice(0, numEnemies);
        
        usedConfigs.forEach((config, i) => {
          if (this.textures.exists(config.type)) {
            const spacing = 80;
            const startX = Math.max(420, displayW - 300);
            const ex = startX + (i * spacing);
            
            const enemy = this.add.sprite(ex, ch - 18, config.type, 0).setOrigin(0.5, 1);
            enemy.setScale(playerScale);
            enemy.health = config.health;
            enemy.maxHealth = config.health;
            enemy.type = config.type;
            enemy.name = config.name;
            enemy.aiTimer = 0;
            enemy.speed = config.speed;
            enemy.attackCooldown = 0;
            enemy.attackCadence = config.cadence;
            enemy.attackReach = 24;
            enemy.attackWidth = 20;
            enemy.attackHeight = 18;
            enemy.lastDirection = 1; // For AI movement tracking
            enemy.aggroRange = 120; // How close player needs to be to activate AI
            
            // Create enemy health bar
            enemy.healthBarBg = this.add.rectangle(0, 0, 32, 4, 0x333333).setOrigin(0.5, 1).setDepth(9999);
            enemy.healthBar = this.add.rectangle(0, 0, 30, 2, 0xff0000).setOrigin(0.5, 1).setDepth(10000);
            
            // Update health bar position function
            enemy.updateHealthBar = () => {
              if (enemy.healthBarBg && enemy.healthBar) {
                enemy.healthBarBg.setPosition(enemy.x, enemy.y - enemy.height * enemy.scaleY - 5);
                enemy.healthBar.setPosition(enemy.x, enemy.y - enemy.height * enemy.scaleY - 5);
                
                const healthPercent = enemy.health / enemy.maxHealth;
                enemy.healthBar.width = 30 * healthPercent;
                
                // Color based on health
                if (healthPercent > 0.7) {
                  enemy.healthBar.fillColor = 0x00ff00;
                } else if (healthPercent > 0.3) {
                  enemy.healthBar.fillColor = 0xffaa00;
                } else {
                  enemy.healthBar.fillColor = 0xff0000;
                }
                
                // Hide when at full health or defeated
                const shouldShow = enemy.health < enemy.maxHealth && enemy.health > 0 && !enemy._defeated;
                enemy.healthBarBg.setVisible(shouldShow);
                enemy.healthBar.setVisible(shouldShow);
              }
            };
            
            this.enemies.push(enemy);
          }
        });
  // Enhanced boss spawning (Miller)
  step('boss (manual spawn)');
  
  // Array of available boss configurations
  this.bossConfigs = [
    // Default Miller (preloaded in preload())
    { key: 'boss', name: 'Miller', health: 140, speed: 0.8, cadence: 850, description: 'Street Boss',
      load: async () => true, // already preloaded in preload
      prefix: 'boss' },
    // Boss 2: Necromancer PNG sequence pack (Idle/Walking/Slashing). Files already transparent.
    { key: 'boss2', name: 'Necromancer', health: 160, speed: 0.85, cadence: 800, description: 'Alt Boss (Necro)', prefix: 'boss2',
      load: async () => {
        try {
          if (this._necroReady) return true;
          const base = `${ASSETS_BASE}/sprites/necro/Necromancer_of_the_Shadow_3/PNG/PNG Sequences`;
          // Frame counts taken from asset folder
          const seqs = [
            { key: 'idle',     dir: 'Idle',     count: 18 },
            { key: 'walk',     dir: 'Walking',  count: 24 },
            { key: 'attack',   dir: 'Slashing', count: 12 }
          ];
          const toKeys = [];
          // Stage 1: load all images
      await new Promise((resolve) => {
            seqs.forEach(seq => {
              for (let i=0; i<seq.count; i++) {
                const idx = String(i).padStart(3,'0');
                const file = `0_Necromancer_of_the_Shadow_${seq.dir.replace(/\s+/g,'_')}_${idx}.png`;
        const url = encodeURI(`${base}/${seq.dir}/${file}`);
                const frameKey = `necro_raw_${seq.key}_${i}`;
                toKeys.push(frameKey);
        this.load.image(frameKey, url);
              }
            });
      this.load.on('loaderror', (file) => { try { const d=document.getElementById('dialogue-text'); if (d) d.textContent = `Necro load error: ${file?.src||''}`; } catch(_) {} });
            this.load.once('complete', resolve);
            this.load.start();
          });
          // Stage 2: pad to uniform canvas so feet align and width is stable
          let maxW=0, maxH=0;
          toKeys.forEach(k => {
            try {
              const img = this.textures.get(k)?.getSourceImage();
              if (img) { maxW = Math.max(maxW, img.width||0); maxH = Math.max(maxH, img.height||0); }
            } catch(_) {}
          });
          // Fallback sizes if something odd
          maxW = Math.max(48, maxW|0);
          maxH = Math.max(48, maxH|0);
          const paddedOf = (rawKey) => {
            const padKey = `${rawKey}_pad`;
            if (this.textures.exists(padKey)) return padKey;
            try {
              const src = this.textures.get(rawKey)?.getSourceImage();
              if (!src) return rawKey;
              const w = src.width, h = src.height;
              const t = this.textures.createCanvas(padKey, maxW, maxH);
              const c = t.getContext();
              c.imageSmoothingEnabled = false; c.clearRect(0,0,maxW,maxH);
              // bottom-center align
              const dx = Math.floor((maxW - w)/2);
              const dy = Math.max(0, maxH - h);
              c.drawImage(src, dx, dy);
              t.refresh();
              return padKey;
            } catch(_) { return rawKey; }
          };
          const buildAnim = (name, count) => {
            const frames = [];
            for (let i=0; i<count; i++) {
              const raw = `necro_raw_${name}_${i}`;
              const key = paddedOf(raw);
              frames.push({ key, frame: 0 });
            }
            return frames;
          };
          const pref = 'boss2';
          const idleF = buildAnim('idle', 18);
          const walkF = buildAnim('walk', 24);
          const atkF  = buildAnim('attack', 12);
          // Remove if already present
          ['idle','walk','attack'].forEach(n => { if (this.anims.exists(`${pref}-${n}`)) this.anims.remove(`${pref}-${n}`); });
          this.anims.create({ key: `${pref}-idle`,    frames: idleF, frameRate: 6,  repeat: -1 });
          this.anims.create({ key: `${pref}-walk`,    frames: walkF, frameRate: 10, repeat: -1 });
          this.anims.create({ key: `${pref}-attack`,  frames: atkF,  frameRate: 12, repeat: 0 });
          // Expose a safe default texture key for spawning
          try { this._necroFirstFrameKey = idleF?.[0]?.key || null; } catch(_) { this._necroFirstFrameKey = null; }
          // If boss already exists and is Necro, force it to play the new idle
          try { if (this.boss && this.bossAnimPrefix === pref) this.boss.play(`${pref}-idle`); } catch(_) {}
          this._necroReady = true;
          return true;
        } catch(e) {
          console.warn('Necro load failed', e);
          return false;
        }
      }
    }
  ];
  this.currentBossConfig = this.bossConfigs[0];
  this.bossName = 'Miller';
  this.boss = null;
  this._bossSpawning = false;
  try { const cb = document.getElementById('devBoss'); if (cb) cb.checked = false; } catch(_) {}
        
        // Create Alex animations using heuristic row/column ranges with URL override support
  step('anims');
  const SHEET = { fw:16, fh:32, margin:1, spacing:1 };
  const alexImg = this.textures.get('alex').source?.[0];
  const sheetW = alexImg?.width || 0;
  const sheetH = alexImg?.height || 0;
  // Derive frames-per-row/col exactly like Phaser's spritesheet parser: (size - 2*margin + spacing) / (frame + spacing)
  const cols = sheetW ? Math.max(1, Math.floor((sheetW - (SHEET.margin*2) + SHEET.spacing) / (SHEET.fw + SHEET.spacing))) : 8;
  const rows = sheetH ? Math.max(1, Math.floor((sheetH - (SHEET.margin*2) + SHEET.spacing) / (SHEET.fh + SHEET.spacing))) : 6;
  const idx = (r,c) => (Math.max(0, Math.min(rows-1, r)) * cols) + Math.max(0, Math.min(cols-1, c));
  const parseMap = () => {
    const params = new URLSearchParams(location.search);
    const raw = params.get('alexMap'); // e.g., walk=0:0-1;punch=1:0-2;kick=2:0-2;jump=3:0-1
    if (!raw) return null;
    const out = {};
    raw.split(';').forEach(part => {
      const [k, spec] = part.split('=');
      if (!k || !spec) return;
      const [rowStr, colsStr] = spec.split(':');
      const r = parseInt(rowStr, 10);
      const [a,b] = (colsStr||'0-0').split('-').map(x=>parseInt(x,10));
      out[k.trim()] = { row: isNaN(r)?0:r, from: isNaN(a)?0:a, to: isNaN(b)?a:b };
    });
    return out;
  };
  const map = parseMap() || {
    // Enhanced movement with more frames for smoother animation
    walk:  { row: 0, from: 0, to: Math.min(3, cols-1) }, // More walking frames
    punch: { row: 1, from: 0, to: Math.min(3, cols-1) }, // Extended punch combo
    // Kick provisional (will auto-tune below)
    kick:  { row: 2, from: 0, to: Math.min(2, cols-1) },
    // Jump left as-is since you’re happy with it
    jump:  { row: 0, from: 0, to: 0 }
  };

  // Auto-select a non-ducking kick row by scanning pixels (if no explicit URL override)
  (function autoPickKickRow(){
    const hasOverride = new URLSearchParams(location.search).get('alexMap');
    if (hasOverride) return; // user-specified mapping wins
    try {
      const tex = this.textures.get('alex');
      const src = tex.getSourceImage();
      if (!src) return;
      const tmp = document.createElement('canvas');
      const ctx = tmp.getContext('2d', { willReadFrequently: true });
      const heightScores = [];
      const scoreRow = (r) => {
        // sample first 3 columns on this row
        let heights = [];
        for (let c = 0; c < Math.min(3, cols); c++) {
          const fIdx = idx(r, c);
          const f = this.textures.getFrame('alex', fIdx);
          if (!f) continue;
          tmp.width = f.cutWidth; tmp.height = f.cutHeight;
          ctx.clearRect(0,0,tmp.width,tmp.height);
          ctx.drawImage(f.source.image, f.cutX, f.cutY, f.cutWidth, f.cutHeight, 0, 0, f.cutWidth, f.cutHeight);
          const data = ctx.getImageData(0,0,tmp.width,tmp.height).data;
          // compute alpha bbox
          let top = tmp.height, bottom = -1;
          for (let y=0; y<tmp.height; y++) {
            for (let x=0; x<tmp.width; x++) {
              const a = data[(y*tmp.width + x)*4 + 3];
              if (a > 8) { if (y < top) top = y; if (y > bottom) bottom = y; }
            }
          }
          if (bottom >= top) heights.push(bottom - top + 1);
        }
        if (!heights.length) return 0;
        heights.sort((a,b)=>a-b); const mid = heights[Math.floor(heights.length/2)];
        return mid || 0;
      };
      for (let r=0;r<rows;r++) {
        // skip rows already used by walk or punch
        if (r === map.walk.row || r === map.punch.row) continue;
        heightScores.push({ r, h: scoreRow(r) });
      }
      // prefer taller rows (avoid crouch/duck which are short)
      heightScores.sort((a,b)=>b.h - a.h);
      const best = heightScores.find(s => s.h >= 24) || heightScores[0];
      if (best && Number.isFinite(best.r)) {
        map.kick.row = best.r;
        console.log('Auto-picked kick row', best);
      }
    } catch(e) { console.warn('autoPickKickRow failed', e); }
  }).call(this);
  // Build trimmed textures for used frames to remove deadspace
  const usedIdx = new Set();
  const addRange = (m) => { if (!m) return; for (let c=m.from; c<=m.to; c++) usedIdx.add(idx(m.row, c)); };
  addRange(map.walk); addRange(map.punch); addRange(map.kick); usedIdx.add(idx(map.jump.row, map.jump.from));
  const trimKeyOf = (fIndex) => `alex_t_${fIndex}`;
  try {
    const tmp = document.createElement('canvas');
    const ctx = tmp.getContext('2d', { willReadFrequently: true });
    usedIdx.forEach(fIndex => {
      const f = this.textures.getFrame('alex', fIndex);
      if (!f) return;
      tmp.width = f.cutWidth; tmp.height = f.cutHeight;
      ctx.clearRect(0,0,tmp.width,tmp.height);
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(f.source.image, f.cutX, f.cutY, f.cutWidth, f.cutHeight, 0, 0, f.cutWidth, f.cutHeight);
      const img = ctx.getImageData(0,0,tmp.width,tmp.height);
      const data = img.data;
      let minX=tmp.width, minY=tmp.height, maxX=-1, maxY=-1;
      for (let y=0;y<tmp.height;y++) {
        for (let x=0;x<tmp.width;x++) {
          const a = data[(y*tmp.width + x)*4 + 3];
          if (a>8) { if (x<minX) minX=x; if (y<minY) minY=y; if (x>maxX) maxX=x; if (y>maxY) maxY=y; }
        }
      }
      if (maxX<minX || maxY<minY) { // fully empty? create tiny transparent
        minX=0; minY=0; maxX=1; maxY=1;
      }
      const w = Math.max(1, maxX-minX+1);
      const h = Math.max(1, maxY-minY+1);
      // Create a canvas texture per frame
      const key = trimKeyOf(fIndex);
      if (this.textures.exists(key)) this.textures.remove(key);
      const ct = this.textures.createCanvas(key, w, h);
      const c2 = ct.getContext();
      c2.imageSmoothingEnabled = false;
      c2.drawImage(tmp, minX, minY, w, h, 0, 0, w, h);
      ct.refresh();
    });
  } catch(e) { console.warn('Trimming frames failed', e); }

  // Use only the base spritesheet frames for stability (avoid trimmed frame size jitter)
  const range = (k) => {
    const m = map[k]; if (!m) return [{ key: 'alex', frame: 0 }];
    const frames = [];
    for (let c=m.from; c<=m.to; c++) {
      const fIndex = idx(m.row, c);
      frames.push({ key: 'alex', frame: fIndex });
    }
    return frames.length ? frames : [{ key: 'alex', frame: 0 }];
  };

  // Build color-keyed frames (same size as original) by clearing a dominant border color.
  // This avoids opaque background boxes during special moves without introducing trim jitter.
  // NOTE: To match the real game’s arm/leg motion for attacks, the player sheet needs distinct frames for:
  //  - Walk cycle: 2+ frames
  //  - Punch: at least wind-up and impact frames (2–3)
  //  - Kick: at least lift and extension frames (2–3)
  // The included 'Ryan' sheet (playable character) generally contains these. Use ?pc=ryan to try it.
  // If not sufficient, provide a 16x32 spritesheet with rows/columns for walk/punch/kick. Ideal layout:
  //    Row0: walk 0..3 | Row1: punch 0..3 | Row2: kick 0..3 | Row3: jump 0..1
  //  Frame size: 16x32 (margin=1, spacing=1). Sources: Spriters Resource (RCR sheets), or paid packs from itch.io.
  const colorKeyFrames = (m, prefix='alex_ck') => {
    if (!m) return range('punch');
    const frames = [];
    const tmp = document.createElement('canvas');
    const ctx = tmp.getContext('2d', { willReadFrequently: true });
    const pickKeyColor = (imgData, w, h) => {
      const corners = [
        0, 0,
        (w-1), 0,
        0, (h-1),
        (w-1), (h-1)
      ];
      const counts = new Map();
      for (let i=0; i<corners.length; i+=2) {
        const x = corners[i], y = corners[i+1];
        const idxPx = (y*w + x) * 4;
        const r = imgData[idxPx], g = imgData[idxPx+1], b = imgData[idxPx+2];
        const key = `${r},${g},${b}`;
        counts.set(key, (counts.get(key)||0)+1);
      }
      let best = null, bestN = -1;
      for (const [k, n] of counts.entries()) { if (n > bestN) { best = k; bestN = n; } }
      if (!best) return null;
      const [R,G,B] = best.split(',').map(x=>parseInt(x,10));
      return {R,G,B};
    };
    for (let c=m.from; c<=m.to; c++) {
      const fIndex = idx(m.row, c);
      const f = this.textures.getFrame('alex', fIndex);
      if (!f) continue;
      const w = f.cutWidth, h = f.cutHeight;
      tmp.width = w; tmp.height = h;
      ctx.clearRect(0,0,w,h);
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(f.source.image, f.cutX, f.cutY, w, h, 0, 0, w, h);
      const img = ctx.getImageData(0,0,w,h);
      const data = img.data;
      const keyCol = pickKeyColor(data, w, h);
      if (keyCol) {
        const {R,G,B} = keyCol;
        const thr = 30; // small tolerance
        for (let p=0; p<data.length; p+=4) {
          const r=data[p], g=data[p+1], b=data[p+2];
          if (Math.abs(r-R)+Math.abs(g-G)+Math.abs(b-B) <= thr) data[p+3] = 0;
        }
        ctx.putImageData(img, 0, 0);
      }
      const texKey = `${prefix}_${fIndex}`;
      if (this.textures.exists(texKey)) this.textures.remove(texKey);
      const t = this.textures.createCanvas(texKey, w, h);
      const c2 = t.getContext();
      c2.imageSmoothingEnabled = false;
      c2.clearRect(0,0,w,h);
      c2.drawImage(tmp, 0, 0);
      t.refresh();
      frames.push({ key: texKey, frame: 0 });
    }
    return frames.length ? frames : range('punch');
  };
  // Enhanced animation creation with smoother frame rates
  {
    const usingSkeleton = this._playerIsSkeleton === true;
    if (!usingSkeleton) {
      this.anims.create({ key: 'alex-idle', frames: [{ key: 'alex', frame: idx(map.walk.row, map.walk.from) }], frameRate: 2, repeat: -1 });
      this.anims.create({ key: 'alex-walk', frames: range('walk'), frameRate: 12, repeat: -1 }); // Smoother walking
      // Run uses the same frames as walk but much faster
      this.anims.create({ key: 'alex-run', frames: range('walk'), frameRate: 18, repeat: -1 }); // Faster running
      this.anims.create({ key: 'alex-punch', frames: range('punch'), frameRate: 15, repeat: 0 }); // Faster punching
      // Kick: use base spritesheet frames for stability
      this.anims.create({ key: 'alex-kick',  frames: range('kick'),  frameRate: 12, repeat: 0 });

      // Enhanced jump animation with better transitions
      const jIndex = idx(map.jump.row, map.jump.from);
      const jf = [{ key: 'alex', frame: jIndex }];
      this.anims.create({ key: 'alex-jump', frames: jf, frameRate: 8, repeat: -1 });

      // Add hurt animation if frames exist
      if (map.hurt) {
        this.anims.create({ key: 'alex-hurt', frames: range('hurt'), frameRate: 8, repeat: 0 });
      }
    }
  }
        
        // Create enemy animations for each type - simplified
    const enemyAnimTypes = ['enemy1', 'enemy2', 'enemy3'];
  enemyAnimTypes.forEach(enemyType => {
          if (this.textures.exists(enemyType)) {
            this.anims.create({
              key: `${enemyType}-idle`,
              frames: [{ key: enemyType, frame: 0 }],
              frameRate: 1,
              repeat: 0
            });
            
            this.anims.create({
              key: `${enemyType}-walk`,
              frames: [{ key: enemyType, frame: 0 }, { key: enemyType, frame: 1 }],
              frameRate: 6,
              repeat: -1
            });
          }
        });
  // Boss animation builder (parameterized by texture key and prefix)
  this.buildBossAnimations = (texKey, prefix) => {
    try {
      if (!this.textures.exists(texKey)) return false;
      const frameCount = this.textures.get(texKey).frameTotal;
      const ckFrames = [];
      const tmp = document.createElement('canvas');
      const ctx = tmp.getContext('2d', { willReadFrequently: true });
      const pickKeyColor = (imgData, w, h) => {
        const corners = [0,0, (w-1),0, 0,(h-1), (w-1),(h-1)];
        const scores = new Map();
        for (let i=0;i<corners.length;i+=2) {
          const x=corners[i], y=corners[i+1];
          const p=((y*w)+x)*4; const r=imgData[p], g=imgData[p+1], b=imgData[p+2];
          const k=`${r},${g},${b}`; scores.set(k,(scores.get(k)||0)+1);
        }
        let best=null, n=-1; for (const [k,v] of scores) { if (v>n) { best=k; n=v; } }
        if (!best) return null; const [R,G,B]=best.split(',').map(x=>parseInt(x,10));
        const isMagenta = (R>170 && B>170 && G<140) || (R>150 && B>150 && (R+ B) > G*2);
        const isNearBlack = (R<8 && G<8 && B<8);
        const isNearWhite = (R>248 && G>248 && B>248);
        return (isMagenta || isNearBlack || isNearWhite) ? {R,G,B} : null;
      };
      for (let fi=0; fi<Math.max(1, frameCount); fi++) {
        const f = this.textures.getFrame(texKey, fi);
        if (!f) { ckFrames.push({ key: texKey, frame: Math.min(fi, frameCount-1) }); continue; }
        const w=f.cutWidth, h=f.cutHeight; tmp.width=w; tmp.height=h; ctx.clearRect(0,0,w,h);
        ctx.imageSmoothingEnabled=false;
        ctx.drawImage(f.source.image, f.cutX, f.cutY, w, h, 0, 0, w, h);
        const img=ctx.getImageData(0,0,w,h); const data=img.data;
        const keyCol = pickKeyColor(data, w, h);
        const R = keyCol?.R, G = keyCol?.G, B = keyCol?.B;
        if (R !== undefined) {
          // Use conservative threshold for black/white, wider for magenta
          let thr = 34; // default for magenta-like
          if (R<8 && G<8 && B<8) thr = 5;       // near black background
          if (R>248 && G>248 && B>248) thr = 8; // near white background
          for (let p=0;p<data.length;p+=4) {
            const r=data[p], g=data[p+1], b=data[p+2];
            if (Math.abs(r-R)+Math.abs(g-G)+Math.abs(b-B) <= thr) data[p+3]=0;
          }
          ctx.putImageData(img,0,0);
        }
        const texKey2=`${prefix}_ck_${fi}`; if (this.textures.exists(texKey2)) this.textures.remove(texKey2);
        const canv=this.textures.createCanvas(texKey2, w, h); const c2=canv.getContext();
        c2.imageSmoothingEnabled=false; c2.clearRect(0,0,w,h); c2.drawImage(tmp,0,0); canv.refresh();
        ckFrames.push({ key: texKey2, frame: 0 });
      }
      const idleFrame = ckFrames[0] || { key: texKey, frame: 0 };
      const walkFrames = [idleFrame];
      const fIdle = `${prefix}-idle`;
      const fWalk = `${prefix}-walk`;
      const fAtk  = `${prefix}-attack`;
      if (this.anims.exists(fIdle)) this.anims.remove(fIdle);
      if (this.anims.exists(fWalk)) this.anims.remove(fWalk);
      if (this.anims.exists(fAtk))  this.anims.remove(fAtk);
      this.anims.create({ key: fIdle, frames: [idleFrame], frameRate: 1, repeat: -1 });
      this.anims.create({ key: fWalk, frames: walkFrames, frameRate: walkFrames.length>1?6:1, repeat: -1 });
      const atkFrames = (ckFrames && ckFrames.length > 1) ? [ckFrames[1], idleFrame, ckFrames[1]] : [idleFrame];
      this.anims.create({ key: fAtk, frames: atkFrames, frameRate: (atkFrames.length>1?14:1), repeat: 0 });
      return true;
    } catch(e) { console.warn('buildBossAnimations failed', e); return false; }
  };
  // Build default Miller animations with prefix 'boss'
  if (this.textures.exists('boss')) {
    this.buildBossAnimations('boss', 'boss');
  } else {
    console.warn('Boss texture not loaded properly');
  }
        
        // Start animations
  this.alex.play('alex-idle');
        this.enemies.forEach(enemy => {
          enemy.play(`${enemy.type}-idle`);
        });
  if (this.boss) this.boss.play('boss-idle');
        
        // Input setup
  step('input');
  try {
    // Initialize input controls with safety checks
    if (this.input && this.input.keyboard) {
      this.cursors = this.input.keyboard.createCursorKeys() || {};
  this.keys = this.input.keyboard.addKeys('A,S,D,SPACE,Q,E') || {};
      // Gamepad mapping and on-screen hints
      try {
        const dlg = document.getElementById('dialogue');
        const setHint = (msg) => { const t = document.getElementById('dialogue-text'); if (t) t.textContent = msg; };
        const showHints = () => { if (dlg) dlg.style.display = 'block'; setHint('Gamepad: A = Punch  |  B = Kick  |  X = Jump'); };
        const hideHints = () => { try { if (dlg) dlg.style.display = 'none'; } catch(_) {} };
        this.input.gamepad.on('connected', () => showHints());
        this.input.gamepad.on('disconnected', () => hideHints());
        if (this.input.gamepad.total) showHints();
        // Per-frame poll function
        this._pollPad = () => {
          const pads = this.input.gamepad?.gamepads || [];
          const p = pads[0]; if (!p) return;
          // Map standard buttons
          if (!this.isAttacking) {
            if (p.buttons[0]?.pressed) this._doPunch && this._doPunch(); // A
            if (p.buttons[1]?.pressed) this._doKick && this._doKick();   // B
            if (p.buttons[2]?.pressed) this._doJump && this._doJump();   // X
          }
          if (p.buttons[9]?.pressed) this.enterPause && this.enterPause(); // Start
        };
      } catch(_) {}
      
      // Dev: quick spawn with B key
      if (this.keys && Phaser.Input.Keyboard.KeyCodes) {
        this.keys.B = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.B);
      }
    } else {
      // Fallbacks if keyboard input is unavailable
      this.cursors = {};
      this.keys = {};
    }
  } catch(e) {
    console.warn('Failed to initialize keyboard controls:', e);
    this.cursors = {};
    this.keys = {};
  }
  // Define action helpers for reuse (keyboard + gamepad)
  this._doPunch = () => { try { if (!this.isAttacking) { this.isAttacking = true; this.attackType = 'punch'; this.attackTimer = 0; } } catch(_) {} };
  this._doKick  = () => { try { if (!this.isAttacking) { this.isAttacking = true; this.attackType = 'kick';  this.attackTimer = 0; } } catch(_) {} };
  this._doJump  = () => { try { if (!this.isAttacking && this.alexJumpZ === 0) { this.alexVy = this.JUMP_VELOCITY; this.playSfx(['sfx_jump1','sfx_jump2'], 0.45, 1.0); } } catch(_) {} };

  // Pause / Mute keys with enhanced safety checks
        try {
          // Initialize pauseKeys as an empty object by default to prevent undefined errors
          this.pauseKeys = {};
          
          if (this.input && this.input.keyboard) {
            const KC = Phaser.Input.Keyboard.KeyCodes;
            if (KC) {
              // Only assign keys if the KeyCodes are available
              this.pauseKeys = {
                esc: this.input.keyboard.addKey(KC.ESC) || null,
                p: this.input.keyboard.addKey(KC.P) || null,
                m: this.input.keyboard.addKey(KC.M) || null
              };
            }
          }
        } catch(e) {
          console.warn('Failed to initialize pause keys:', e);
          // Ensure pauseKeys is an object even if initialization fails
          this.pauseKeys = { esc: null, p: null, m: null };
        }
        
        // Guarantee pauseKeys exists (double safety)
        if (!this.pauseKeys) {
          this.pauseKeys = { esc: null, p: null, m: null };
        }
        // Dev flags and helpers
        this.godMode = false;
        this.setGodMode = (on) => { this.godMode = !!on; this.showMessage(this.godMode ? 'God Mode: ON' : 'God Mode: OFF'); };
  this.spawnBossNearPlayer = async () => {
          try {
      // Replace any existing boss to avoid duplicates
      if (this.boss) { try { this.boss.destroy(); } catch(_) {} this.boss = null; }
      if (this._bossSpawning) { this.showMessage('Boss spawn in progress…'); return null; }
      this._bossSpawning = true;
            
            // Create a brand new boss sprite
            const createNewBossSprite = () => {
              // Force load the boss sprite directly from file - bypassing texture cache issues
              const img = new Image();
              img.src = asset('sprites/boss_sprite.png');
              
              // Create a new texture when image loads
              img.onload = () => {
                if (!this.textures.exists('boss_direct')) {
                  this.textures.addImage('boss_direct', img);
                  console.log('Created boss_direct texture from image');
                  
                  // Create a sprite with the new texture
                  this.createBossWithTexture('boss_direct');
                }
              };
              
              img.onerror = (err) => {
                console.error('Error loading boss image:', err);
                // Fall back to enemy1 sprite if boss can't be loaded
                const fallbackKey = this.textures.exists('enemy1') ? 'enemy1' : null;
                if (fallbackKey) {
                  this.createBossWithTexture(fallbackKey);
                } else {
                  this.showMessage('Boss sprite could not be loaded.');
                }
              };
            };
            
            // Helper function to create boss with a specific texture
            this.createBossWithTexture = (textureKey, animPrefix='boss') => {
              // Position boss about ~10 feet from player (game scale) to avoid overlap on spawn
              const px = (this.alex?.x || 200);
              const bgW = (this.bg?.displayWidth || this.scale?.width || this.scale?.gameSize?.width || 800);
              const margin = 40;
              // Treat ~10 feet as ~60px at base scale; adjust slightly with background scale
              const pxPerFoot = 6; // heuristic
              const offset = Math.max(40, Math.round(pxPerFoot * 10 * (this.bg?.scaleX || 1)));
              const preferred = px + ((this.alex && this.alex.flipX) ? -offset : offset);
              let bx = Phaser.Math.Clamp(preferred, margin, bgW - margin);
              // If too close due to bounds, try the opposite side with same offset
              if (Math.abs(bx - px) < Math.min(40, offset*0.9)) {
                const alt = px + ((this.alex && this.alex.flipX) ? offset : -offset);
                bx = Phaser.Math.Clamp(alt, margin, bgW - margin);
              }
              
              // Fallback ground if baseY not initialized yet
              const groundY = Number.isFinite(this.baseYMax) ? this.baseYMax : 
                ((this.scale.height || this.scale.gameSize?.height || 480) - 18);
              
              // Create boss sprite
              // Use base frame; some single-frame textures (like padded Necro images) don't have frame index 0
              const boss = this.add.sprite(bx, groundY, textureKey)
                .setOrigin(0.5, 1)
                .setDepth(10);
              // Force visibility and normal alpha to avoid invisible spawns
              try { boss.setVisible(true); boss.setAlpha(1); boss.clearTint(); boss.setBlendMode(Phaser.BlendModes.NORMAL); } catch(_) {}
              
              console.log('Boss created with texture:', textureKey);
              // Temporary marker to visualize spawn position while we debug visibility
              try {
                const m = this.add.rectangle(boss.x, boss.y - Math.max(6, boss.displayHeight*0.9), 6, 6, 0xffff00)
                  .setOrigin(0.5).setDepth(10001);
                this.time.delayedCall(1500, () => { try { m.destroy(); } catch(_) {} });
              } catch(_) {}
              try { const d=document.getElementById('dialogue-text'); if (d) d.textContent = `${this.bossName||'Boss'} spawned at (${Math.round(boss.x)}, ${Math.round(boss.y)}) key=${textureKey}`; } catch(_) {}
              
              // Decide animation prefix early so scale can use it
              this.bossAnimPrefix = animPrefix || 'boss';
        // Set proper scale to match the game world
              const enemyScale = this.bg?.scaleX || 1;
        // Scale Necro to match player's displayed height; default to 1.0 for Miller
              let scaleAdj = 1.0;
        if (this.bossAnimPrefix === 'boss2') {
                try {
                  const f = this.textures.getFrame(textureKey, 0);
                  const srcH = Math.max(1, (f?.cutHeight || f?.height || f?.source?.height || 128));
          const playerH = Math.max(1, this.alex?.displayHeight || 32);
    const desired = playerH; // same height as player
      // Adjust so final applied scale (enemyScale * scaleAdj) yields desired height
    scaleAdj = Phaser.Math.Clamp(desired / (srcH * enemyScale), 0.08, 0.6);
    } catch(_) { scaleAdj = 0.5; }
              }
        boss.setScale(enemyScale * scaleAdj);
        // Measure transparent padding below the visible feet to keep feet on the road
        try {
          if (this.bossAnimPrefix === 'boss2') {
            const tex = this.textures.get(textureKey);
            const img = tex?.getSourceImage ? tex.getSourceImage() : null;
            if (img) {
              const cv = document.createElement('canvas');
              cv.width = img.width; cv.height = img.height;
              const cx = cv.getContext('2d', { willReadFrequently: true });
              cx.clearRect(0,0,cv.width,cv.height); cx.drawImage(img, 0, 0);
              const data = cx.getImageData(0,0,cv.width,cv.height).data;
              let bottomAlphaRow = -1;
              outer: for (let y=cv.height-1; y>=0; y--) {
                for (let x=0; x<cv.width; x++) {
                  const a = data[(y*cv.width + x)*4 + 3];
                  if (a > 8) { bottomAlphaRow = y; break outer; }
                }
              }
              if (bottomAlphaRow >= 0) {
                const padPx = (cv.height - 1) - bottomAlphaRow; // transparent rows under silhouette
                boss._footPadRaw = padPx; // store raw pad for future resizes
                boss._footPadScaled = Math.round(padPx * (boss.scaleY || 1));
              }
            }
          }
        } catch(_) { boss._footPadScaled = boss._footPadScaled || 0; }
        this._currentBossScaleAdj = scaleAdj; // remember for resize
              // Snap to whole pixels to prevent tearing between rows/cols
              boss.x = Math.round(boss.x); boss.y = Math.round(boss.y);
              
              // Make sure the boss sprite is fully visible
              boss.x = Phaser.Math.Clamp(boss.x, 40, (this.bg.displayWidth || 800) - 40);
              
              // Set boss properties
              boss.health = 140;
              boss.type = textureKey;
              boss.speed = (this.bossAnimPrefix==='boss2') ? 0.95 : 0.8;
              boss.attackCooldown = 0;
              boss.attackCadence = 600; // swing more often
              boss.attackReach = (this.bossAnimPrefix==='boss2') ? 32 : 30;
              boss.attackWidth = (this.bossAnimPrefix==='boss2') ? 22 : 24;
              boss.attackHeight = (this.bossAnimPrefix==='boss2') ? 18 : 20;

              // Align feet to the same ground as the player (account for any invisible bottom padding)
              try {
                // Place so that feet baseline equals player lane Y
                const pad = (boss._footPadScaled||0);
                const bias = this.feetBiasFor(boss,'boss');
                boss.y = Math.round(this.alexBaseY + pad + bias);
              } catch(_) {}
              
              // Prefer animations by prefix; build if missing
              if (!this.anims.exists(`${this.bossAnimPrefix}-idle`)) {
                try { this.buildBossAnimations(textureKey, this.bossAnimPrefix); } catch(_) {}
              }
              if (this.anims.exists(`${this.bossAnimPrefix}-idle`)) {
                boss.play(`${this.bossAnimPrefix}-idle`);
              } else {
                const idleKey = `${textureKey}-idle`;
                if (!this.anims.exists(idleKey)) {
                  this.anims.create({ key: idleKey, frames: [{ key: textureKey, frame: 0 }], frameRate: 1, repeat: -1 });
                }
                boss.play(idleKey);
              }
              
              this.bossName = this.bossName || (animPrefix==='boss2' ? 'Test Boss' : 'Miller');
              this.boss = boss;
              this._bossSpawning = false;
              
              // Briefly highlight boss for visibility
              boss.setTint(0xff55ff);
              this.time.delayedCall(120, () => {
                if (boss && boss.active) boss.clearTint();
                try { this.input.off('pointerdown', next); } catch(_) {}
              });
              
              this.showMessage(`${this.bossName} spawned nearby.`);
              
              // Reflect in Dev UI
              try { 
                const cb = document.getElementById('devBoss'); 
                if (cb) cb.checked = true; 
              } catch(_) {}
              
              return boss;
            };
            
            // Try creating boss with existing texture first
            const useCfg = this.currentBossConfig || this.bossConfigs[0];
            // Ensure texture present (dynamic load for alt)
            const trySpawnWith = (key, prefix) => {
              try { return this.createBossWithTexture(key, prefix); } catch(_) { return null; }
            };
            if (useCfg.key === 'boss2') {
              try { const d=document.getElementById('dialogue-text'); if (d) d.textContent = 'Loading Necromancer…'; } catch(_) {}
              try {
                const ok = await useCfg.load();
                if (ok) {
                  if (this.boss && this.boss.active && !this.boss._defeated) { this._bossSpawning = false; return this.boss; }
                  const firstKey = this._necroFirstFrameKey || 'necro_raw_idle_0_pad';
                  if (this.textures.exists(firstKey)) { const r = trySpawnWith(firstKey, useCfg.prefix||'boss2'); this._bossSpawning = false; return r; }
                  const blankKey = 'boss2_blank';
                  if (!this.textures.exists(blankKey)) {
                    const t = this.textures.createCanvas(blankKey, 2, 2); const c=t.getContext(); c.clearRect(0,0,2,2); t.refresh();
                  }
                  const r = trySpawnWith(blankKey, useCfg.prefix||'boss2'); this._bossSpawning = false; return r;
                }
                this.showMessage('Necro assets missing; check necro PNG sequence folders');
                this._bossSpawning = false;
                return null;
              } catch(_) { /* fall through */ }
            }
            if (this.textures.exists('boss')) {
              const r = this.createBossWithTexture('boss', 'boss'); this._bossSpawning = false; return r;
            } else if (this.textures.exists('boss_direct')) {
              const r = this.createBossWithTexture('boss_direct', 'boss'); this._bossSpawning = false; return r;
            } else if (this.textures.exists('boss_backup')) {
              const r = this.createBossWithTexture('boss_backup', 'boss'); this._bossSpawning = false; return r;
            } else {
              // If no boss texture exists, create one
              createNewBossSprite();
              // For immediate feedback, try enemy1 as fallback
              if (this.textures.exists('enemy1')) {
                const r = this.createBossWithTexture('enemy1', 'boss'); this._bossSpawning = false; return r;
              }
              this._bossSpawning = false;
            }
            
          } catch(err) {
            console.error('Boss spawn error:', err);
            this._bossSpawning = false;
            // Try with enemy1 if available
            try {
              if (this.textures.exists('enemy1')) {
                return this.createBossWithTexture('enemy1');
              }
            } catch(_) {}
            return null;
          }
        };
        this.despawnBoss = () => { try { if (this.boss) { this.boss.destroy(); this.boss = null; this.showMessage('Boss despawned.'); } this._bossSpawning = false; } catch(_) {} };
        
  // Game state
  this.isMoving = false;
  this.isAttacking = false;
  // Double-tap to run state
  this.runState = { isRunning:false, dir:0, lastTap:{ left:0, right:0 }, threshold: 280 };
  // Lane movement + jump physics (jump height separate from lane Y)
  // Constrain to detected road band; fallback to constant if detection unavailable
  this.ROAD_TOP_PCT = 0.65;
  // Constrain to detected road band at start as well
  const roadTop0 = Math.round(ch * (this._roadTopFrac || this.ROAD_TOP_PCT));
  const roadBot0 = Math.round(ch * (this._roadBottomFrac || 0.96));
  // Full blue band playable (+2px slack at the bottom)
  this.baseYMin = roadTop0;
  this.baseYMax = Math.min(ch - 1, roadBot0 + 2);
  this.alexBaseY = this.baseYMax;
  this.alexJumpZ = 0; // negative while rising
  this.alexVy = 0;
  this.GRAVITY = 0.28; // slightly slower fall for longer airtime
  this.JUMP_VELOCITY = -12.0; // slightly softer takeoff
  this.alex.y = Math.round(this.alexBaseY + this.alexJumpZ);
  // Player hurt / invulnerability window
  this.playerInvulUntil = 0; // timestamp in ms
        
  console.log('Baden City Ransom scene ready. Background cropped to road.');
  // Enhanced HUD with combo display
  const dbg = this.add.text(6, 6, '', { fontFamily: 'monospace', fontSize: '12px', color: '#0f0' }).setDepth(10000).setScrollFactor(0);
  
  // Add combo display
  this.comboDisplay = this.add.text(6, 30, '', { 
    fontFamily: 'monospace', fontSize: '14px', color: '#ffff00', stroke: '#000', strokeThickness: 2 
  }).setDepth(10000).setScrollFactor(0);
  
  // Add health bar for Alex
  this.healthBarBg = this.add.rectangle(10, 50, 120, 12, 0x333333).setOrigin(0, 0).setDepth(9999).setScrollFactor(0);
  this.healthBar = this.add.rectangle(12, 52, 116, 8, 0x00ff00).setOrigin(0, 0).setDepth(10000).setScrollFactor(0);
  this.healthText = this.add.text(140, 50, 'Health: 100', { 
    fontFamily: 'monospace', fontSize: '12px', color: '#ffffff' 
  }).setDepth(10000).setScrollFactor(0);
  
  // Make debug updater available to other methods via the scene instance
  this.updateDebug = () => {
    const s = [
      `cw:${this.scale.width} ch:${this.scale.height}`,
      `bgKey:${this._bgKey || this.bg?.texture?.key || '?'} bgScale:${this.bg?.scaleX?.toFixed ? this.bg.scaleX.toFixed(2) : '1.00'}`,
      `parallax:${Math.round(this._parallaxX)}`,
      `alex:${Math.round(this.alex.x)},${Math.round(this.alex.y)} run:${this.runState?.isRunning?'Y':'N'}`,
      this._playerIsSkeleton ? 'player: skeleton' : `sheet ${cols}x${rows}  map w:${map.walk.row}:${map.walk.from}-${map.walk.to} p:${map.punch.row}:${map.punch.from}-${map.punch.to} k:${map.kick.row}:${map.kick.from}-${map.kick.to} j:${map.jump.row}:${map.jump.from}-${map.jump.to}`
    ].join('  ');
    dbg.setText(s);
    
    // Update combo display
    if (this.comboCount > 1) {
      this.comboDisplay.setText(`COMBO: ${this.comboCount}x`);
      this.comboDisplay.setVisible(true);
      // Pulse effect for high combos
      if (this.comboCount > 3) {
        this.comboDisplay.setScale(1 + Math.sin(this.time.now * 0.01) * 0.1);
      } else {
        this.comboDisplay.setScale(1);
      }
    } else {
      this.comboDisplay.setVisible(false);
    }
    
    // Update health bar
    const healthPercent = (this.alex.health || 0) / 100;
    this.healthBar.width = 116 * healthPercent;
    
    // Change color based on health
    if (healthPercent > 0.6) {
      this.healthBar.fillColor = 0x00ff00; // Green
    } else if (healthPercent > 0.3) {
      this.healthBar.fillColor = 0xffff00; // Yellow
    } else {
      this.healthBar.fillColor = 0xff0000; // Red
    }
    
    this.healthText.setText(`Health: ${Math.ceil(this.alex.health || 0)}`);
  };
  this.updateDebug();
        
        // Ensure background continues to fit if the canvas size changes
        this.scale.on('resize', (gameSize) => {
          const w = gameSize?.width || this.scale.width || this.scale.gameSize?.width || canvasWrap?.clientWidth || 800;
          const h = gameSize?.height || this.scale.height || this.scale.gameSize?.height || canvasWrap?.clientHeight || 480;
          applyResize(w, h);
          this.updateDebug();
        });
        // Apply a couple of staged resizes to settle layout after the Title height swap
        const s0 = getSize();
        applyResize(s0.cw, s0.ch);
        try {
          this.time.delayedCall(16, () => { const s = getSize(); applyResize(s.cw, s.ch); this.updateDebug(); });
          this.time.delayedCall(80, () => { const s = getSize(); applyResize(s.cw, s.ch); this.updateDebug(); });
        } catch(_) {}
  // Play contemplation track for this level (fallback to street_music)
  step('music');
  try { const a = this.sound.get('startscreen'); if (a) { a.stop(); a.destroy(); } } catch(_) {}
  const savedVol = Number(window._BCRSET?.get('musicVol', 0.35));
  const savedMute = !!window._BCRSET?.get('musicMute', false);
  // Prefer contemplation if it actually loaded; otherwise fall back cleanly
  let musKey = 'contemplation';
  try {
    const hasContemplation = !!this.cache?.audio?.exists?.('contemplation');
    if (!hasContemplation) musKey = 'street_music';
  } catch(_) { musKey = 'street_music'; }
  this.music = this.sound.add(musKey, { loop: true, volume: isFinite(savedVol) ? savedVol : 0.35, mute: savedMute });
        const startMusic = () => { if (!this.music.isPlaying) this.music.play(); };
        if (this.sound.locked) {
          this.sound.once('unlocked', startMusic);
          this.input.once('pointerdown', startMusic);
          try { this.input.keyboard?.once('keydown', startMusic); } catch(_) {}
        } else {
          startMusic();
        }
  // Auto-pause and resume music based on scene pause/resume
  this.events.on('pause', () => { try { this.music?.pause(); } catch(_) {} });
  this.events.on('resume', () => {
    try { this.music?.resume(); } catch(_) {}
    // Do not modify player position when closing the store UI
  });
  // Add visible shop doors on the roadside (support 1-2 per level)
  try {
    const has = (k) => this.textures.exists(k);
    this.shops = [
      { x: 260, radius: 40, texKey: has('shop_ext_electronics') ? 'shop_ext_electronics' : (has('shop_ext_grocery')?'shop_ext_grocery':null) },
      { x: 680, radius: 40, texKey: has('shop_ext_icecream') ? 'shop_ext_icecream' : (has('shop_ext_grocery')?'shop_ext_grocery':null) },
    ].filter(s => !!s.texKey);
    this.shopDoors = [];
    this.shops.forEach(s => {
      const door = this.add.image(0,0,s.texKey).setOrigin(0.5,1);
      door._shopRef = s;
      // Immediate sizing/positioning so the player never appears behind initially
      try {
        const w = this.scale.width || this.scale.gameSize?.width || 800;
        const h = this.scale.height || this.scale.gameSize?.height || 480;
        const roadTop = Math.round(h * (this._roadTopFrac || this.ROAD_TOP_PCT));
        const alexH = Math.max(32, Math.floor((this.alex?.displayHeight || 0)));
        const baseH = (alexH ? Math.floor(alexH * 1.15) : Math.floor(h * 0.24));
        const doorH = Math.max(48, Math.floor(baseH * 1.25));
        const doorW = Math.floor((doorH * 0.70) * 1.5);
        const scaleX = this.bg?.scaleX || 1;
        door.setDisplaySize(doorW, doorH);
        door.x = Math.floor((s.x||260) * scaleX);
        door.y = Math.floor(roadTop);
  door.setDepth(-100);
        try { if (door._shopRef) door._shopRef.radius = Math.max(door._shopRef.radius||0, Math.round(doorW * 0.6)); } catch(_) {}
      } catch(_) {}
      this.shopDoors.push(door);
    });
    // Keep legacy this.shop for prompt logic centered on first shop
    if (!this.shop && this.shops[0]) this.shop = { x: this.shops[0].x, radius: this.shops[0].radius, prompt: null, inZone: false };
  } catch(_) {}
        // Small helper to play short SFX with minimal overlap
        this._sfxGateTs = 0;
        this.playSfx = (keys, volume=0.5, rate=1.0, duckMs=120, duckVol=0.25) => {
          try {
            if (this.sound.locked) return; // should be unlocked after title
            const now = this.time.now || 0;
            if (now - (this._sfxGateTs||0) < 40) return; // gentle spam gate
            this._sfxGateTs = now;
            const list = Array.isArray(keys) ? keys : [keys];
            const key = list[(Math.random()*list.length)|0];
            if (!this.sound?.get(key)) { /* okay */ }
            const s = this.sound.add(key, { volume, rate });
            s.once('complete', () => s.destroy());
            // Brief music ducking while SFX plays
            const prevVol = this.music?.volume ?? 0.35;
            if (this.music && duckMs>0) {
              this.music.setVolume(Math.max(0, Math.min(prevVol, duckVol)));
              this.time.delayedCall(duckMs, () => { if (this.music) this.music.setVolume(prevVol); });
            }
            s.play();
          } catch (_) { /* ignore */ }
        };
        // Lightweight synthesized SFX (no asset needed)
        this.synth = {
          click: (freq=1100, dur=0.035, vol=0.12) => {
            try {
              const ctx = this.sound.context; const t = ctx.currentTime;
              const o = ctx.createOscillator(); const g = ctx.createGain();
              o.type = 'square'; o.frequency.setValueAtTime(freq, t);
              g.gain.setValueAtTime(0.0001, t);
              g.gain.linearRampToValueAtTime(vol, t + 0.006);
              g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
              o.connect(g).connect(ctx.destination);
              o.start(t); o.stop(t + dur + 0.01);
            } catch(_) {}
          },
          thump: (freq=90, dur=0.12, vol=0.22) => {
            try {
              const ctx = this.sound.context; const t = ctx.currentTime;
              const o = ctx.createOscillator(); const g = ctx.createGain(); const f = ctx.createBiquadFilter();
              o.type = 'sine'; o.frequency.setValueAtTime(freq, t);
              f.type = 'lowpass'; f.frequency.setValueAtTime(240, t);
              g.gain.setValueAtTime(0.0001, t);
              g.gain.linearRampToValueAtTime(vol, t + 0.01);
              g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
              o.connect(f).connect(g).connect(ctx.destination);
              o.start(t); o.stop(t + dur + 0.02);
            } catch(_) {}
          }
          ,
          coin: () => {
            try {
              const ctx = this.sound.context; const t0 = ctx.currentTime;
              const mk = (freq, start, dur, vol=0.18) => {
                const o = ctx.createOscillator(); const g = ctx.createGain();
                o.type = 'sine'; o.frequency.setValueAtTime(freq, start);
                g.gain.setValueAtTime(0.0001, start);
                g.gain.linearRampToValueAtTime(vol, start + 0.01);
                g.gain.exponentialRampToValueAtTime(0.0001, start + dur);
                o.connect(g).connect(ctx.destination);
                o.start(start); o.stop(start + dur + 0.01);
              };
              // Two short, bright pings for a coin-like chime
              mk(1800, t0, 0.10, 0.16);
              mk(2400, t0 + 0.035, 0.09, 0.14);
            } catch(_) {}
          }
        };
        
        // Function to show messages in dialogue bar
        this.showMessage = (text) => {
          document.getElementById('dialogue-text').innerHTML = text;
        };
        // HUD: pulse wallet and show a brief +$ float when money changes
        this.onMoneyChanged = (delta=0) => {
          try {
            const wrap = document.getElementById('moneyWrap');
            const valWrap = document.getElementById('moneyValWrap') || wrap;
            if (!wrap) return;
            // retrigger CSS pulse
            wrap.classList.remove('gainFlash');
            void wrap.offsetWidth; // reflow
            wrap.classList.add('gainFlash');
            if (delta) {
              const el = document.createElement('span');
              el.className = 'hudGain';
              const sign = delta>0 ? '+' : '-';
              el.textContent = `${sign}$${Math.abs(delta).toFixed(0)}`;
              valWrap.appendChild(el);
              requestAnimationFrame(() => el.classList.add('show'));
              setTimeout(() => { try { el.remove(); } catch(_) {} }, 900);
            }
          } catch(_) {}
        };
        // Buff HUD updater: show compact icons only; hide row entirely when no buffs
    this.updateBuffHUD = () => {
          try {
            const el = document.getElementById('buffs'); if (!el) return;
            const iconRow = document.getElementById('buffIcons');
      if (iconRow) { while (iconRow.firstChild) iconRow.removeChild(iconRow.firstChild); }
            const parts = [];
            const nowMs = this.time?.now || 0;
            // Speed boost
            if (this.speedBoostUntil && nowMs < this.speedBoostUntil) {
              const left = Math.max(0, Math.ceil((this.speedBoostUntil - nowMs)/1000));
              parts.push(`Speed x1.3 ${left}s`);
              if (iconRow) {
                const n = document.createElement('span');
                n.className = 'ico'; n.title = `Speed Boost x1.3 (${left}s)`;
                n.textContent = '🏃';
                iconRow.appendChild(n);
              }
            }
            // Coin purse bonus
            const cvb = Math.max(0, Math.min(90, Math.round(((this.coinValueBonus||0) * 100))));
            if (cvb > 0) parts.push(`Coins +${cvb}%`);
            if (cvb > 0 && iconRow) {
              const n = document.createElement('span');
              n.className = 'ico'; n.title = `Coin Value +${cvb}%`;
              n.textContent = '🪙';
              const b = document.createElement('span'); b.className='badge'; b.textContent = `+${cvb}%`;
              n.appendChild(b);
              iconRow.appendChild(n);
            }
            // City map
            if (this.cityMapOwned) {
              parts.push('Map');
              if (iconRow) { const n = document.createElement('span'); n.className='ico'; n.title='City Map (exits visible)'; n.textContent='🗺️'; iconRow.appendChild(n); }
            }
            // Hide verbose text and use tooltip on the icon row instead
            try { el.textContent = ''; el.style.display = 'none'; } catch(_) {}
            if (iconRow) {
              const has = iconRow.childElementCount > 0;
              iconRow.style.display = has ? 'inline-flex' : 'none';
              iconRow.title = has ? parts.join(' | ') : 'No buffs';
            }
          } catch(_) {}
        };
        // Expose simple toggles for PauseOverlay to call
        this.toggleMusicMute = () => {
          try {
            if (this.music) {
              this.music.setMute(!this.music.mute);
              try { window._BCRSET?.set('musicMute', !!this.music.mute); } catch(_) {}
              this.showMessage(this.music.mute ? 'Music muted' : 'Music unmuted');
            }
          } catch(_) {}
        };
        this.adjustMusicVolume = (delta=0) => {
          try {
            if (!this.music) return;
            const v = Math.max(0, Math.min(1, (this.music.volume ?? 0.35) + delta));
            this.music.setVolume(v);
            try { window._BCRSET?.set('musicVol', v); } catch(_) {}
            this.showMessage(`Music volume: ${(v*100|0)}%`);
          } catch(_) {}
        };
        this.enterPause = () => {
          try {
            if (!this.scene.isActive('PauseOverlay')) {
              this.scene.launch('PauseOverlay');
              this.scene.pause();
            }
          } catch(_) {}
        };

        // Feet baseline helpers so boxes attach to bodies (not to image bottoms or shadows)
        this.feetBiasFor = (spr, role='enemy') => {
          try {
            const h = Math.max(1, spr.displayHeight || spr.height || 32);
            if (role === 'player') return Math.round(Math.max(2, h * 0.18));
            if (role === 'boss') {
              // For Necro, use zero extra bias; footPad handles transparency padding
              return (this.bossAnimPrefix === 'boss2') ? 0 : 0;
            }
            return Math.round(Math.max(1, h * 0.10));
          } catch(_) { return 4; }
        };
        this.feetYOf = (spr, role='enemy') => {
          try {
            const pad = spr?._footPadScaled || 0;
            const bias = this.feetBiasFor(spr, role);
            return (spr?.y || 0) - pad - bias;
          } catch(_) { return (spr?.y||0); }
        };

        // True feet baseline (no bias) for placing boxes exactly relative to ground
        this.baselineYOf = (spr) => {
          try {
            const pad = spr?._footPadScaled || 0;
            return (spr?.y || 0) - pad;
          } catch(_) { return (spr?.y||0); }
        };

        // Tighter hurtbox helper (feet-anchored, narrower than full sprite bounds)
        this.hurtboxOf = (spr, role='enemy') => {
          try {
            const w = Math.max(1, spr.displayWidth || spr.width || 16);
            const h = Math.max(1, spr.displayHeight || spr.height || 32);
            const widthFrac = (role==='player') ? 0.38 : (role==='boss' ? 0.46 : 0.42);
            const heightFrac = (role==='boss') ? 0.55 : 0.52;
            const hbW = Math.max(2, w * widthFrac);
            const hbH = Math.max(2, h * heightFrac);
            const x = (spr.x || 0) - hbW/2;
            // Player: anchor to true feet baseline and lift a few px for torso alignment
            if (role === 'player') {
              const base = this.baselineYOf(spr);
              const bottomClear = Math.round(Math.max(4, h * 0.06)); // keep a few px above feet
              const y = base - bottomClear - hbH;
              return new Phaser.Geom.Rectangle(Math.round(x), Math.round(y), Math.round(hbW), Math.round(hbH));
            }
            // Others: use feet-biased anchor that centers on body mass
            const feetY = this.feetYOf(spr, role);
            const y = feetY - hbH - 1;
            return new Phaser.Geom.Rectangle(Math.round(x), Math.round(y), Math.round(hbW), Math.round(hbH));
          } catch(_) {
            return new Phaser.Geom.Rectangle((spr?.x||0)-6, (spr?.y||0)-10, 12, 10);
          }
        };

        // Auto-pause on window blur or page hidden
        try {
          const onBlur = () => { try { this.enterPause && this.enterPause(); } catch(_) {} };
          const onVis = () => { try { if (document.hidden) this.enterPause && this.enterPause(); } catch(_) {} };
          window.addEventListener('blur', onBlur);
          document.addEventListener('visibilitychange', onVis);
          this.events.once('shutdown', () => {
            try { window.removeEventListener('blur', onBlur); } catch(_) {}
            try { document.removeEventListener('visibilitychange', onVis); } catch(_) {}
          });
        } catch(_) {}
        
  this.showMessage('Welcome to Baden City! Fight your way through the gangs!');
  // Initial Buff HUD render
  try { this.updateBuffHUD && this.updateBuffHUD(); } catch(_) {}
  // Setup simple shop state and prompt (hidden until near shop zone)
  this.shop = { x: 260, radius: 34, prompt: null, inZone: false };
  try {
    const py = Math.floor(this.scale.height * 0.90);
  this.shop.prompt = this.add.text(this.scale.width/2, Math.max(12, Math.floor(this.scale.height * (this._roadTopFrac || this.ROAD_TOP_PCT)) - 10), 'Press E to Enter Shop', {
      fontFamily:'monospace', fontSize:'18px', color:'#ffffaa', stroke:'#000', strokeThickness:4
    }).setDepth(5000).setScrollFactor(0).setOrigin(0.5).setVisible(false);
  } catch(_) {}
  step('ready');
  console.log('Game scene created successfully!');
        } catch (err) {
          console.error('GAME CREATION ERROR:', err);
          console.error('Error stack:', err.stack);
          diag(`CRITICAL ERROR: ${err?.message || err}`);
          
          // Try to create a minimal fallback scene instead of black screen
          try {
            this.add.text(400, 240, 'Game Error - Check Console', { 
              fontSize: '24px', 
              color: '#ff0000',
              fontFamily: 'monospace'
            }).setOrigin(0.5);
            
            this.add.text(400, 280, `Error: ${err?.message || 'Unknown error'}`, { 
              fontSize: '16px', 
              color: '#ffff00',
              fontFamily: 'monospace'
            }).setOrigin(0.5);
          } catch(_) {}
          
          // Do not return - let the scene exist even with errors
        }
      }
      
      update(time) {
  // Ensure safe defaults if create() failed early
  if (!this.cursors) this.cursors = { left:{isDown:false}, right:{isDown:false}, up:{isDown:false}, down:{isDown:false} };
  if (!this.keys) this.keys = {};
  if (!this.runState) this.runState = { isRunning:false, dir:0, lastTap:{ left:0, right:0 }, threshold: 280 };
  const prevX = this.alex?.x || 0;
        // Pause toggle with enhanced safety checks
        try {
          // Safely check for undefined values with defensive coding
          const JustDown = Phaser.Input.Keyboard?.JustDown;
          if (typeof JustDown === 'function' && this.pauseKeys) {
            const escPressed = this.pauseKeys.esc && JustDown(this.pauseKeys.esc);
            const pPressed = this.pauseKeys.p && JustDown(this.pauseKeys.p);
            
            if (escPressed || pPressed) {
              this.enterPause && this.enterPause();
              return; // stop processing this frame
            }
            
            // Music mute toggle with similar safety
            if (this.pauseKeys && this.pauseKeys.m && JustDown(this.pauseKeys.m)) {
              this.toggleMusicMute && this.toggleMusicMute();
            }
          }
        } catch(e) {
          console.warn('Error checking pause keys:', e);
        }
        // Dev: quick boss spawn
        try {
          const JustDown = Phaser.Input.Keyboard?.JustDown;
          if (typeof JustDown === 'function' && this.keys && this.keys.B) {
            if (JustDown(this.keys.B)) {
              typeof this.spawnBossNearPlayer === 'function' && this.spawnBossNearPlayer();
            }
          }
        } catch(e) {
          console.warn('Error checking boss key:', e);
        }
  // Alex movement with double-tap run
        let moving = false;
        const now = time;
        // detect taps
        const tap = (side) => {
          const last = this.runState.lastTap[side] || 0;
          const dt = now - last;
          this.runState.lastTap[side] = now;
          if (dt > 0 && dt < this.runState.threshold) {
            this.runState.isRunning = true;
            this.runState.dir = (side==='left'?-1:1);
          }
        };
        if (Phaser.Input.Keyboard.JustDown(this.cursors.left)) tap('left');
        if (Phaser.Input.Keyboard.JustDown(this.cursors.right)) tap('right');

        // Gamepad axes + d-pad to digital directions
        let padLeft=false, padRight=false, padUp=false, padDown=false;
        try {
          const pads = this.input.gamepad?.gamepads || [];
          const p = pads[0];
          if (p) {
            const axX = p.axes?.[0]?.getValue?.() ?? 0;
            const axY = p.axes?.[1]?.getValue?.() ?? 0;
            const dead = 0.25;
            padLeft = axX < -dead || !!p.buttons?.[14]?.pressed;
            padRight = axX > dead || !!p.buttons?.[15]?.pressed;
            padUp = axY < -dead || !!p.buttons?.[12]?.pressed;
            padDown = axY > dead || !!p.buttons?.[13]?.pressed;
            // Optional: treat hard tilt as run intent
            if (Math.abs(axX) > 0.9) {
              this.runState.isRunning = true;
              this.runState.dir = axX < 0 ? -1 : 1;
            }
          }
        } catch(_) {}

  const baseSpeed = 2;
        // Temporary speed boost support
        const boostActive = (this.speedBoostUntil && (time < this.speedBoostUntil));
        const boostMul = boostActive ? 1.3 : 1.0;
        const speed = (this.runState.isRunning ? 3.8 * boostMul : baseSpeed * boostMul);

    if (!this.isAttacking && (this.cursors.left.isDown || padLeft)) {
          this.alex.x -= speed;
          this.alex.setFlipX(true);
          moving = true;
          if (this.runState.isRunning && this.runState.dir !== -1) this.runState.isRunning = false;
    } else if (!this.isAttacking && (this.cursors.right.isDown || padRight)) {
          this.alex.x += speed;
          this.alex.setFlipX(false);
          moving = true;
          if (this.runState.isRunning && this.runState.dir !== 1) this.runState.isRunning = false;
        } else {
          // No horizontal input: stop running
          this.runState.isRunning = false;
        }
        
        // Lane up/down movement along the road
  if (!this.isAttacking && (this.cursors.up.isDown || padUp)) { this.alexBaseY -= speed; moving = true; }
  else if (!this.isAttacking && (this.cursors.down.isDown || padDown)) { this.alexBaseY += speed; moving = true; }
  // Clamp base Y to full lane; alex.y = alexBaseY + jumpZ so feet can reach exact bottom with slack
  this.alexBaseY = Phaser.Math.Clamp(this.alexBaseY, this.baseYMin, this.baseYMax);

    // Gamepad poll
    try { this._pollPad && this._pollPad(); } catch(_) {}

    // Jump with D if not already airborne
        const onGround = this.alexJumpZ === 0;
  if (!this.isAttacking && Phaser.Input.Keyboard.JustDown(this.keys.D) && onGround) { this._doJump && this._doJump(); }
        // Apply jump gravity to jump height only
        const wasAir = !onGround || this.alexVy !== 0;
        if (!onGround || this.alexVy !== 0) {
          this.alexJumpZ += this.alexVy;
          this.alexVy += this.GRAVITY;
          if (this.alexJumpZ >= 0) { this.alexJumpZ = 0; this.alexVy = 0; }
        }
        // Compose final render Y
        this.alex.y = Math.round(this.alexBaseY + this.alexJumpZ);
        // Landing detect: transitioning from air to ground this frame
        const nowOnGround = (this.alexJumpZ === 0 && this.alexVy === 0);
        if (wasAir && nowOnGround) {
          this.synth.thump(95, 0.1, 0.18);
        }
        
  // Animation handling
        if (!onGround && !this.isAttacking) {
          if (this.alex.anims.currentAnim?.key !== 'alex-jump') {
            this.alex.play('alex-jump');
          }
        } else if (moving && !this.isAttacking) {
          const want = this.runState.isRunning ? 'alex-run' : 'alex-walk';
          if (this.alex.anims.currentAnim?.key !== want) this.alex.play(want);
        } else if (!this.isAttacking) {
          if (this.alex.anims.currentAnim?.key !== 'alex-idle') {
            this.alex.play('alex-idle');
          }
        }

  // Update Buff HUD every frame (cheap tiny text update)
  try { this.updateBuffHUD && this.updateBuffHUD(); } catch(_) {}

        // Quick footsteps while running (only when actually moving fast horizontally)
        try {
          const leftHeld = (this.cursors.left.isDown || padLeft);
          const rightHeld = (this.cursors.right.isDown || padRight);
          const horizSpeed = Math.abs((leftHeld?1:0) - (rightHeld?1:0)) * (this.runState.isRunning ? 3.8 : 2);
          if (onGround && this.runState.isRunning && horizSpeed >= 3.5 && !this.isAttacking) {
            const nowMs = this.time.now || 0;
            if (nowMs >= (this._nextStepAt || 0)) {
              // Subtle low thump as a footstep
              this.synth.thump(125, 0.06, 0.10);
              this._nextStepAt = nowMs + 120;
            }
          } else {
            this._nextStepAt = (this.time.now || 0);
          }
        } catch(_) {}
        
        // Enhanced Combat System with combos and variety
        this.comboCount = 0;
        this.comboTimer = 0;
        this.maxCombo = 4;
        
  const tryAttack = (kind) => {
          if (this.isAttacking) return;
          
          // Check for combo continuation
          const now = this.time.now || 0;
          if (now - this.comboTimer > 1000) {
            this.comboCount = 0; // Reset combo if too much time passed
          }
          
          this.isAttacking = true;
          this.comboCount = Math.min(this.comboCount + 1, this.maxCombo);
          this.comboTimer = now;
          
          // Enhanced animation with combo effects
          const animKey = (kind==='kick') ? 'alex-kick' : (kind==='special' ? 'alex-special' : 'alex-punch');
          this.alex.play(animKey);
          
          // Combo-based visual effects
          const tilt = (kind==='kick' ? 6.5 : kind==='special' ? 7 : 5) * Math.min(1.2, 1 + this.comboCount * 0.08);
          this.tweens.add({ 
            targets: this.alex, 
            angle: (this.alex.flipX ? -tilt : tilt), 
            duration: Math.max(60, 90 - this.comboCount * 5), 
            yoyo: true, 
            onComplete: () => { this.alex.setAngle(0); } 
          });
          
          // Enhanced recoil based on combo
          try {
            const baseRecoil = (kind === 'kick') ? 4.2 : (kind==='punch'? 3.2 : 2.5);
            const recoil = baseRecoil * (1 + this.comboCount * 0.15);
            const worldW = (this._bgNaturalW||800) * (this.bg?.scaleX||1);
            this.alex.x += this.alex.flipX ? recoil : -recoil;
            this.alex.x = Phaser.Math.Clamp(this.alex.x, 16, worldW - 16);
          } catch(_) {}

          // Tiny forward lunge for punch/kick only (special stays put)
          try {
            if (kind==='punch' || kind==='kick') {
              const lunge = (kind==='kick' ? 6 : 4) * (1 + this.comboCount * 0.05);
              const dir = this.alex.flipX ? -1 : 1;
              const targetX = Phaser.Math.Clamp(this.alex.x + (lunge * dir), 16, ((this._bgNaturalW||800) * (this.bg?.scaleX||1)) - 16);
              this.tweens.add({ targets: this.alex, x: targetX, duration: 80, ease: 'quad.out' });
            }
          } catch(_) {}
          
          // Enhanced SFX with combo pitch variation
          const pitchVar = 1.0 + (this.comboCount * 0.05);
          this.playSfx(['sfx_punch1','sfx_punch2'], 0.55 + this.comboCount * 0.1, kind==='kick' ? 0.9 * pitchVar : 1.05 * pitchVar);
          
          // Enhanced hitbox with combo scaling
          const baseReach = (kind==='kick') ? 28 : (kind==='special' ? 30 : 24);
          const reach = baseReach * (1 + this.comboCount * 0.08);
          const baseW = (kind==='kick') ? 24 : (kind==='special' ? 16 : 20);
          const w = baseW * (1 + this.comboCount * 0.1);
          const h = 22 + this.comboCount * 2;
          const ox = this.alex.flipX ? -reach : reach;
          const pBase = this.baselineYOf(this.alex);
          // Raise attack box above feet baseline; scale with height so it stays at torso level
          const pH = Math.max(1, this.alex.displayHeight || this.alex.height || 32);
          const lift = Math.round(Math.max(12, pH * 0.28));
          const hitRect = new Phaser.Geom.Rectangle(this.alex.x + ox - w/2, pBase - lift - h, w, h);
          // Expose for debug overlay
          try { this._lastPlayerHitRect = { rect: hitRect, ts: (this.time.now || 0) }; } catch(_) {}

      const applyHit = (target, dmg, knock=6) => {
            if (!target || !target.active || target._defeated) return;
            // Require target to be in front of the player (no hitting behind)
            const facingOk = this.alex.flipX ? (target.x < this.alex.x - 1) : (target.x > this.alex.x + 1);
            if (!facingOk) return;
            const tb = this.hurtboxOf(target, (target===this.boss)?'boss':'enemy');
            if (Phaser.Geom.Intersects.RectangleToRectangle(hitRect, tb)) {
              const comboDamage = dmg * (1 + this.comboCount * 0.2);
              const comboKnockback = knock * (1 + this.comboCount * 0.15);
              
              target.health = Math.max(0, (target.health||1) - comboDamage);
              
              // Enhanced hit effects
              const hitColor = this.comboCount > 2 ? 0xffaa00 : 0xff0000; // Orange for high combo
              target.setTintFill(hitColor);
              this.time.delayedCall(100, () => target.clearTint());
              
              // Combo knockback
              target.x += this.alex.flipX ? -comboKnockback : comboKnockback;
              
              // Enhanced hit sound
              const hitPitch = 1300 + (this.comboCount * 200);
              this.synth.click(hitPitch, 0.03 + this.comboCount * 0.01, 0.10);
              
              // Show combo count
              if (this.comboCount > 1) {
                const comboText = this.add.text(target.x, target.y - 40, `${this.comboCount}x COMBO!`, {
                  fontSize: '12px', fontFamily: 'monospace', color: '#ffff00', stroke: '#000', strokeThickness: 2
                }).setOrigin(0.5);
                
                this.tweens.add({
                  targets: comboText,
                  y: comboText.y - 30,
                  alpha: 0,
                  duration: 800,
                  onComplete: () => comboText.destroy()
                });
              }
              
              // Defeat logic
              if (target.health === 0 && !target._defeated) {
                target._defeated = true; 
                target.play(`${target.type||'boss'}-idle`);
                
                // Enhanced defeat effect
                this.tweens.add({ 
                  targets: target, 
                  alpha: 0, 
                  scaleX: target.scaleX * 1.1,
                  scaleY: target.scaleY * 1.1,
                  duration: 600, 
                  onComplete: () => {
                    // Drop 1-3 coins at the enemy feet baseline
                    try {
                      const dropCount = Phaser.Math.Between(1, 3);
                      const role = (target===this.boss)?'boss':'enemy';
                      const baseY = this.feetYOf(target, role);
                      if (!this.coins) this.coins = [];
                      for (let i=0; i<dropCount; i++) {
                        const dx = (-10 + i*10) + Phaser.Math.Between(-3,3);
                        const coin = this.add.sprite(target.x + dx, baseY - 6, 'coin_spin_0').setOrigin(0.5, 1).setDepth(3000);
                        coin.play('coin-spin');
                        coin.value = 1; // Flat value per coin
                        // Right-size coin relative to player: ~24% of player height in world pixels, clamped
                        const pixelScale = (this.bg?.scaleX||1);
                        const alexDispH = Math.max(1, this.alex?.displayHeight || 32);
                        const playerWorldH = alexDispH / pixelScale; // convert to background (world) pixels
                        // One-notch larger: about 18% of player height; modest clamp
                        const coinWorldPx = Phaser.Math.Clamp(Math.round(playerWorldH * 0.18), 7, 11);
                        const coinScreenPx = coinWorldPx * pixelScale;
                        try { coin.setDisplaySize(coinScreenPx, coinScreenPx); } catch(_) { coin.setScale(pixelScale * (coinWorldPx / 12)); }
                        // Simple physics for drop/bounce
                        coin._baseY = baseY - 6;
                        // Start with a tiny pop upward and outward
                        const velScale = pixelScale;
                        coin._vx = Phaser.Math.Between(-25, 25) * velScale;
                        coin._vy = -Phaser.Math.Between(70, 110) * velScale;
                        coin._g  = 380 * velScale; // gravity
                        coin._phys = true;
                        coin._despawnAt = (this.time.now||0) + Phaser.Math.Between(8000, 12000);
                        this.coins.push(coin);
                      }
                    } catch(_) {}
                    if (target === this.boss) {
                      this.showMessage((this.bossName||'Boss') + ' defeated!');
                    } else {
                      // Add money reward
                      const bounty = (5 + this.comboCount * 2);
                      this.alex.money = (this.alex.money || 0) + bounty;
                      try { this.onMoneyChanged && this.onMoneyChanged(+bounty); } catch(_) {}
                      this.showMessage(`${target.name || 'Enemy'} defeated! +$${bounty}`);
                    }
                    target.destroy();
                  }
                });
              }
            }
          };

          // Combo-based damage scaling
          const baseDmg = (kind==='kick') ? 18 : (kind==='special' ? 22 : 14);
          const dmg = baseDmg * (1 + this.comboCount * 0.25);
          const knockEnemy = (kind==='kick') ? 7 : (kind==='punch' ? 6 : 5);
          const knockBoss = (kind==='kick') ? 10 : (kind==='punch' ? 9 : 8);
          this.enemies.forEach(e => applyHit(e, dmg, knockEnemy));
          if (this.boss) applyHit(this.boss, dmg, knockBoss);

          // Only clear attacking when the specific attack animation completes
          const ev = `animationcomplete-${(kind==='kick') ? 'alex-kick' : (kind==='special' ? 'alex-special' : 'alex-punch')}`;
          this.alex.once(ev, () => {
            this.isAttacking = false; this.alex.setAngle(0);
            // Clear debug hitbox shortly after animation completes
            try { this._lastPlayerHitRect = null; } catch(_) {}
          });
        };

  if (Phaser.Input.Keyboard.JustDown(this.keys.A)) { this.runState.isRunning=false; tryAttack('punch'); }
  if (Phaser.Input.Keyboard.JustDown(this.keys.S)) { this.runState.isRunning=false; tryAttack('kick'); }
  if (this.keys.Q && Phaser.Input.Keyboard.JustDown(this.keys.Q)) { this.runState.isRunning=false; tryAttack('special'); }
        
    // Keep Alex inside world bounds
  const displayWNow = (this._bgNaturalW||800) * (this.bg?.scaleX||1);
  this.alex.x = Phaser.Math.Clamp(this.alex.x, 16, displayWNow - 16);
    // Cemetery-only logic disabled unless explicitly in cemetery map
        
  // ... (resize listener moved to create())
        
        // Enhanced multi-enemy AI system with varied behaviors
        const hurtPlayer = (dmg, knock=8, dir=1) => {
          if (this.godMode) return; // ignore damage in God Mode
          const nowMs = time;
          if (nowMs < this.playerInvulUntil) return; // i-frames
          
          // Reset combo on taking damage
          this.comboCount = 0;
          
          this.alex.health = Math.max(0, (this.alex.health||0) - dmg);
          this.playerInvulUntil = nowMs + 600; // 600ms i-frames
          this.alex.setTintFill(0xffff77);
          this.time.delayedCall(100, () => this.alex.clearTint());
          
          // Play hurt animation if available
          if (this.alex.anims.exists('alex-hurt')) {
            this.alex.play('alex-hurt');
          }
          
          // knockback along X and tiny vertical wobble
          this.alex.x += (dir<0?-1:1) * knock;
          this.cameras.main.shake(90, 0.004);
          this.synth.click(900, 0.04, 0.12);
          
          if (this.alex.health === 0) {
            // Auto-respawn with blinking invulnerability (classic style)
            this.showMessage('You were knocked out! Respawning...');
            try {
              const respawn = () => {
                // Restore position and health
                const { height:ch } = this.scale;
                const worldW = (this._bgNaturalW||800) * (this.bg?.scaleX||1);
                this.alex.health = 100;
                this.alexBaseY = this.baseYMax;
                this.alexJumpZ = 0; this.alexVy = 0;
                this.alex.x = Phaser.Math.Clamp((this.cameras.main.scrollX||0) + 120, 16, worldW - 16);
                this.alex.y = Math.round(this.alexBaseY);
                // Set longer i-frames and blink
                const now2 = this.time.now || (nowMs+1);
                const INV_MS = 2000;
                this.playerInvulUntil = now2 + INV_MS;
                try { this.tweens.add({ targets: this.alex, alpha: 0.25, yoyo: true, repeat: Math.floor(INV_MS/120), duration: 60 }); } catch(_) {}
                this.showMessage('Back up! (invulnerable)');
              };
              this.time.delayedCall(450, respawn);
            } catch(_) {}
          }
        };
        
        this.enemies.forEach((enemy, index) => {
          if (!enemy || enemy._defeated) return;
          
          const dx = this.alex.x - enemy.x;
          const dy = (this.alexBaseY - enemy.y);
          const distX = Math.abs(dx);
          const distY = Math.abs(dy);
          const totalDist = Math.sqrt(dx*dx + dy*dy);
          
          // Enhanced AI behavior based on enemy type and position
          enemy.setFlipX(dx < 0);
          
          // Check if player is within aggro range
          if (totalDist > enemy.aggroRange) {
            // Idle behavior - light wandering
            if (Math.random() < 0.02) {
              enemy.lastDirection *= -1;
            }
            enemy.x += enemy.lastDirection * 0.3;
            return;
          }
          
          const alignedY = distY <= 12;
          const reach = enemy.attackReach;
          
          // Decide between approach vs idle/attack
          if (distX > reach + 2 || !alignedY) {
            // Different AI patterns based on enemy index
            const aiPattern = index % 3;

            switch(aiPattern) {
              case 0: // Aggressive direct approach
                enemy.x += Math.sign(dx) * enemy.speed * 1.1;
                if (!alignedY) enemy.y += Math.sign(this.alexBaseY - enemy.y) * 0.8;
                break;

              case 1: // Cautious circling
                if (distX > reach + 20) {
                  enemy.x += Math.sign(dx) * enemy.speed;
                  if (!alignedY) enemy.y += Math.sign(this.alexBaseY - enemy.y) * 0.6;
                } else if (distX > reach + 5) {
                  // Circle around player
                  const circleOffset = Math.sin(time * 0.003) * 15;
                  enemy.y += circleOffset * 0.1;
                  enemy.x += Math.sign(dx) * enemy.speed * 0.7;
                }
                break;

              case 2: // Hit and run
                if (enemy.retreating) {
                  enemy.x += Math.sign(dx) * -enemy.speed * 1.2; // Run away
                  if (distX > reach + 40) enemy.retreating = false;
                } else {
                  enemy.x += Math.sign(dx) * enemy.speed * 1.3; // Rush in
                  if (!alignedY) enemy.y += Math.sign(this.alexBaseY - enemy.y) * 0.7;
                }
                break;
            }
            if (enemy.anims.currentAnim?.key !== `${enemy.type}-walk`) enemy.play(`${enemy.type}-walk`);
          } else {
            if (enemy.anims.currentAnim?.key !== `${enemy.type}-idle`) enemy.play(`${enemy.type}-idle`);
            // attempt attack if cooldown over
            if (time >= (enemy.attackCooldown||0)) {
              // attack hitbox in front of enemy
              const w = enemy.attackWidth, h = enemy.attackHeight;
              const ox = enemy.flipX ? -reach : reach;
              const eFeetY = this.feetYOf(enemy, 'enemy');
              const eBase = this.baselineYOf(enemy);
              const hitRect = new Phaser.Geom.Rectangle(enemy.x + ox - w/2, eBase - 5 - h, w, h);
              // Expose for debug overlay
              enemy._lastAtkRect = hitRect; enemy._lastAtkTs = time;
              const pb = this.hurtboxOf(this.alex,'player');
              if (Phaser.Geom.Intersects.RectangleToRectangle(hitRect, pb)) {
                hurtPlayer(10, 10, enemy.flipX?-1:1);
              }
              enemy.attackCooldown = time + enemy.attackCadence;
            }
          }
        });
        // Boss AI (Miller) – completely rewritten for maximum stability
  if (this.boss && !this.boss._defeated) {
          const b = this.boss;
          
          // Fix potential issues with boss sprite visibility
          if (b.alpha < 1) b.alpha = 1;
          if (!b.visible) b.visible = true;
          
          // If the boss has a blank texture, try to fix it
          if (!b.texture || b.texture.key === '__MISSING' || !this.textures.exists(b.texture.key)) {
            console.log('Boss has invalid texture, attempting to fix');
            if (this.textures.exists('boss_direct')) {
              b.setTexture('boss_direct');
            } else if (this.textures.exists('boss')) {
              b.setTexture('boss');
            } else if (this.textures.exists('enemy1')) {
              b.setTexture('enemy1');
            }
          }
          
          const dx = this.alex.x - b.x;
          // Compare lane alignment using feet position (account for bottom padding)
          const bFeetY = this.feetYOf(b, 'boss');
          const dy = (this.alexBaseY - bFeetY);
          
          // Depth sort by Y with a tie-break favoring the player so she isn't visually covered
          try {
            const aY = Math.round(this.alex?.y || 0);
            const bY = Math.round(b?.y || 0);
            if (this.alex?.setDepth) this.alex.setDepth(aY + (aY >= bY ? 1 : 0));
            if (b?.setDepth) b.setDepth(bY + (bY > aY ? 1 : 0));
          } catch(_) {}

          // Set the correct direction the boss is facing
          b.setFlipX(dx < 0);
          
          // Slightly wider tolerance for Necro so she lines up and swings
          const laneTol = (this.bossAnimPrefix==='boss2') ? 13 : 12;
          const alignedY = Math.abs(dy) <= laneTol;
          const distX = Math.abs(dx);
          const reach = b.attackReach || 28;
          
          if (distX > reach + 2 || !alignedY) {
            // Move boss toward player (slightly faster to commit to range), but don't allow overlap
            const stepX = Math.sign(dx) * ((b.speed || 0.8) * (this.bossAnimPrefix==='boss2' ? 1.15 : 1.0));
            const futureDist = Math.abs((b.x + stepX) - this.alex.x);
            const minNoOverlap = Math.max(14, (b.displayWidth ? b.displayWidth * 0.25 : 14));
            if (futureDist > minNoOverlap) {
              b.x += stepX;
            }

            // Keep boss within visible bounds
            b.x = Phaser.Math.Clamp(b.x, 40, (this.bg.displayWidth || 800) - 40);

            // Vertical alignment (lane matching) using feet alignment
            if (!alignedY) {
              const targetY = this.alexBaseY + (b._footPadScaled||0);
              // snap when close; otherwise move faster to line up
              const dyy = targetY - b.y;
              if (Math.abs(dyy) <= 1) {
                b.y = Math.round(targetY);
              } else {
                b.y += Math.sign(dyy) * (this.bossAnimPrefix==='boss2' ? 1.1 : 0.9);
              }
            }
            // Clamp Y within the playable road band so she never walks off-map
            b.y = Phaser.Math.Clamp(b.y, this.baseYMin + (b._footPadScaled||0), this.baseYMax + (b._footPadScaled||0));
            // Re-evaluate clamped y using feet baseline (ensures real feet stay on road)
            const fy = this.feetYOf(b, 'boss');
            if (fy < this.baseYMin) b.y += (this.baseYMin - fy);
            if (fy > this.baseYMax) b.y -= (fy - this.baseYMax);
            // Maintain a little personal space to avoid standing on top
            const minSpace = Math.max(10, (b.displayWidth ? b.displayWidth * 0.18 : 10));
            if (distX < minSpace) {
              // Instead of always backing off, bias into a small forward micro-step to settle into swing range
              const bias = (this.bossAnimPrefix==='boss2') ? 0.35 : 0.25;
              const step = Math.min(1.2, (minSpace - distX) * bias);
              b.x += Math.sign(dx) * step;
            } else if (distX < reach * 0.9) {
              b.x += Math.sign(-dx) * 0.6;
            }

            // Play walk only when not attacking
            try {
              const pref = this.bossAnimPrefix || 'boss';
              const cleanedWalk = `${pref}-walk`;
              const walkAnim = this.anims.exists(cleanedWalk) ? cleanedWalk : `${b.type}-walk`;
              if (!b._attacking && this.anims.exists(walkAnim)) {
                if (b.anims?.currentAnim?.key !== walkAnim) b.play(walkAnim);
              }
            } catch(_) {}

          } else {
            // In range: idle/attack
            try {
              const pref = this.bossAnimPrefix || 'boss';
              const cleanedIdle = `${pref}-idle`;
              const idleAnim = this.anims.exists(cleanedIdle) ? cleanedIdle : `${b.type}-idle`;
              if (!b._attacking && this.anims.exists(idleAnim)) {
                if (b.anims?.currentAnim?.key !== idleAnim) b.play(idleAnim);
              }
            } catch(_) {}

            // Keep a separation even when in range; do not allow overlap
            const minSpaceInRange = Math.max(14, (b.displayWidth ? b.displayWidth * 0.25 : 14));
            if (distX < minSpaceInRange) {
              const repel = Math.min(1.2, (minSpaceInRange - distX) * 0.3);
              // If attacking, push player back; otherwise back the boss off slightly
              if (b._attacking) {
                this.alex.x += (b.flipX ? -repel : repel);
              } else {
                b.x += Math.sign(-dx) * repel;
              }
            }
            // Clamp Y again after nudges
            b.y = Phaser.Math.Clamp(b.y, this.baseYMin + (b._footPadScaled||0), this.baseYMax + (b._footPadScaled||0));
            const fy2 = this.feetYOf(b, 'boss');
            if (fy2 < this.baseYMin) b.y += (this.baseYMin - fy2);
            if (fy2 > this.baseYMax) b.y -= (fy2 - this.baseYMax);

            // Attack when cooldown allows and not already attacking
            // Only attempt an attack when aligned and at a reasonable distance band (not overlapping)
            // Wider near band for Necro so she actually chooses to swing
            const nearBandMin = (this.bossAnimPrefix==='boss2') ? Math.max(0, reach * 0.10) : Math.max(8, reach * 0.35);
            const nearBandMax = (this.bossAnimPrefix==='boss2') ? (reach + 24) : (reach + 4);
            if (!b._attacking && alignedY && distX >= nearBandMin && distX <= nearBandMax && time >= (b.attackCooldown || 0)) {
              try {
                const pref = this.bossAnimPrefix || 'boss';
                const atkKey = `${pref}-attack`;
                if (this.anims.exists(atkKey)) {
                  b._attacking = true;
                  b._attackHitApplied = false;
                  b.play(atkKey);
                  b.once(`animationcomplete-${atkKey}`, () => { b._attacking = false; b._attackHitApplied = false; });
                  // Tiny micro-advance into range at start of swing without overlapping
                  const adv = Math.min(2.0, Math.max(0.5, (distX - (reach*0.6)) * 0.05));
                  const dir = Math.sign(dx);
                  if (Math.abs((b.x + adv*dir) - this.alex.x) > minNoOverlap) b.x += adv * dir;
                } else {
                  // Fallback: flash and briefly pause as a "swing" even without an anim
                  b._attacking = true; b._attackHitApplied = false;
                  b.setTint(0xffcccc);
                  this.time.delayedCall(300, () => { try { b.clearTint(); } catch(_) {} b._attacking=false; b._attackHitApplied=false; });
                }
              } catch(_) { /* ignore */ }

              // Apply damage only during the swing window (mid animation)
              const swingDelay = (this.bossAnimPrefix==='boss2') ? 220 : 280; // Necro hits a bit sooner
              this.time.delayedCall(swingDelay, () => {
                try {
                  // Only hit if still in attack animation and not already applied
                  const pref = this.bossAnimPrefix || 'boss';
                  const atkKey = `${pref}-attack`;
                  if (!b || !b.active || b._attackHitApplied) return;
                  // If the attack animation isn't present, still allow the hit to apply during fallback
                  if (this.anims.exists(atkKey)) {
                    if (!b.anims?.currentAnim || b.anims.currentAnim.key !== atkKey) return;
                  }

                  const w = b.attackWidth || 22, h = b.attackHeight || 20;
                  const ox = b.flipX ? -reach : reach;
                  const bFeetY2 = this.feetYOf(b, 'boss');
                  const bBase = this.baselineYOf(b);
                  const hitRect = new Phaser.Geom.Rectangle(b.x + ox - w/2, bBase - 6 - h, w, h);
                  // Expose for debug overlay
                  b._lastAtkRect = hitRect; b._lastAtkTs = time;
                  const pb = this.hurtboxOf(this.alex,'player');
                  const bFeetNow = this.feetYOf(b,'boss');
                  if (Math.abs(this.alexBaseY - bFeetNow) <= laneTol && Phaser.Geom.Intersects.RectangleToRectangle(hitRect, pb)) {
                    b._attackHitApplied = true;
                    // Push player back on successful hit and add a tiny shake
                    const dir = b.flipX ? -1 : 1;
                    this.alex.x += dir * 4;
                    this.cameras.main.shake(90, 0.004);
                    hurtPlayer(14, 12, dir);
                  }
                } catch(_) {}
              });

              b.attackCooldown = time + (b.attackCadence || 900);
            }
          }
        }
        
        // Shop zone proximity + prompt and key to open shop
        try {
          // Measure proximity to each shop; pick nearest
          let nearest = null, bestDist = Infinity;
          const px = (this.alex?.x||0);
          const scaleX = this.bg?.scaleX || 1;
          (this.shops||[]).forEach(s => {
            const d = Math.abs(px - s.x * scaleX);
            if (d < bestDist) { bestDist = d; nearest = s; }
          });
          const inZone = !!nearest && bestDist <= ((nearest.radius||0) * scaleX);
          this.shop = this.shop || { prompt:null };
          this.shop.inZone = inZone;
          if (this.shop.prompt) {
            this.shop.prompt.setVisible(inZone && !this.isAttacking);
            if (nearest) this.shop.prompt.x = Math.floor((nearest.x||px) * scaleX);
          }
      if (inZone && this.keys.E && Phaser.Input.Keyboard.JustDown(this.keys.E)) {
            // Switch to store interior scene
            try {
        // Save entry door world X (unscaled) for exit positioning
  // Launch the store without changing or tracking player position
  this.scene.launch('StoreScene');
              this.scene.pause();
            } catch(_) {
              // fallback to overlay if StoreScene failed to launch
              if (!this.scene.isActive('ShopOverlay')) { this.scene.launch('ShopOverlay'); this.scene.pause(); }
            }
          }
        } catch(_) {}

        // Update enemy health bars
        this.enemies.forEach(enemy => {
          if (enemy && enemy.updateHealthBar) {
            enemy.updateHealthBar();
          }
        });
        
        // Update boss health bar if it exists
        if (this.boss && this.boss.updateHealthBar) {
          this.boss.updateHealthBar();
        }

        // Coin pickups update
        try {
          if (!this.coins) this.coins = [];
          // Rotate/animate and handle pickups/expiry
          const pb = this.hurtboxOf(this.alex,'player');
          const now = this.time.now || 0;
          this.coins = this.coins.filter(coin => {
            if (!coin || !coin.active) return false;
            // Physics: gravity and bounce with slight damping
            try {
              if (coin._phys) {
                const dt = (this.game.loop.delta||16) / 1000;
                coin._vy += (coin._g||360) * dt;
                coin.x += (coin._vx||0) * dt;
                coin.y += (coin._vy||0) * dt;
                const ground = coin._baseY;
                if (coin.y >= ground) {
                  coin.y = ground;
                  // Bounce with damping
                  coin._vy = -Math.abs(coin._vy) * 0.35;
                  // Horizontal friction
                  coin._vx *= 0.86;
                  // Stop tiny bounces
                  if (Math.abs(coin._vy) < 18) { coin._vy = 0; coin._phys = false; }
                }
              }
            } catch(_) {}
            // Blink before despawn
            if (coin._despawnAt && now > coin._despawnAt - 900) {
              const phase = ((now/120)|0) % 2; coin.setAlpha(phase?0.4:1);
            }
            if (coin._despawnAt && now >= coin._despawnAt) { try { coin.destroy(); } catch(_) {} return false; }
            // Collect on overlap with player hurtbox
            try {
              // Use coin display size for pickup bounds (slightly forgiving height)
              const cw = Math.max(6, Math.round(coin.displayWidth||12));
              const ch = Math.max(6, Math.round((coin.displayHeight||12) * 0.85));
              const cb = new Phaser.Geom.Rectangle(coin.x - cw/2, coin.y - ch, cw, ch);
              if (Phaser.Geom.Intersects.RectangleToRectangle(pb, cb)) {
                let val = coin.value || 1;
                // Apply any store bonus to coin value
                try {
                  const bonus = Math.max(0, Math.min(0.9, this.coinValueBonus||0));
                  if (bonus > 0) val = Math.max(1, Math.round(val * (1 + bonus)));
                } catch(_) {}
                this.alex.money = (this.alex.money||0) + val;
                try { this.onMoneyChanged && this.onMoneyChanged(+val); } catch(_) {}
                // Pickup sound (synth fallback)
                try { this.synth.coin(); } catch(_) { this.playSfx && this.playSfx(['sfx_coin'], 0.6, 1.2); }
                // Floating text
                try {
                  const pixelScale = (this.bg?.scaleX||1);
                  // Keep readable across screens but not oversized
                  const fontPx = Phaser.Math.Clamp(Math.round(10 + (pixelScale-1)*2), 10, 18);
                  const strokePx = Math.max(2, Math.round(fontPx/6));
                  const txt = this.add.text(coin.x, coin.y-18, `+$${val}`, {
                    fontFamily:'monospace', fontSize: `${fontPx}px`, color:'#ffff66',
                    stroke:'#000', strokeThickness: strokePx,
                    shadow:{ offsetX:0, offsetY:0, color:'#000', blur:0, fill:true }
                  }).setOrigin(0.5);
                  const rise = Math.round(16 + (pixelScale-1)*3);
                  this.tweens.add({ targets: txt, y: txt.y - rise, alpha:0, duration:800, onComplete:()=>txt.destroy() });
                } catch(_) {}
                try { coin.destroy(); } catch(_) {}
                return false;
              }
            } catch(_) {}
            return true;
          });
        } catch(_) {}

        // Debug hitbox overlay drawing
        if (this.debugHitboxes) {
          if (!this._hitG || !this._hitG.active) {
            try { this._hitG && this._hitG.destroy(); } catch(_) {}
            this._hitG = this.add.graphics().setDepth(5000);
          }
          const g = this._hitG; g.clear();
          // Player hurtbox (in lieu of full sprite bounds)
          try {
            const pb = this.hurtboxOf(this.alex,'player');
            g.lineStyle(1, 0x00ff00, 1); g.strokeRect(pb.x, pb.y, pb.width, pb.height);
            // Player attack rect (recent)
            if (this._lastPlayerHitRect && (this.time.now - (this._lastPlayerHitRect.ts||0) < 320)) {
              const r = this._lastPlayerHitRect.rect; g.lineStyle(1, 0xff0000, 1); g.strokeRect(r.x, r.y, r.width, r.height);
            }
          } catch(_) {}
          // Enemy bounds and last attack
          try {
            this.enemies.forEach(e => {
              if (!e || e._defeated) return;
              const eb = this.hurtboxOf(e,'enemy'); g.lineStyle(1, 0xffff00, 1); g.strokeRect(eb.x, eb.y, eb.width, eb.height);
              if (e._lastAtkRect && (time - (e._lastAtkTs||0) < 600)) {
                const r = e._lastAtkRect; g.lineStyle(1, 0xff9900, 1); g.strokeRect(r.x, r.y, r.width, r.height);
              }
            });
          } catch(_) {}
          // Boss bounds and last attack
          try {
            if (this.boss && !this.boss._defeated) {
              const bb = this.hurtboxOf(this.boss,'boss'); g.lineStyle(1, 0x00ffff, 1); g.strokeRect(bb.x, bb.y, bb.width, bb.height);
              if (this.boss._lastAtkRect && (time - (this.boss._lastAtkTs||0) < 700)) {
                const r = this.boss._lastAtkRect; g.lineStyle(1, 0x00ccff, 1); g.strokeRect(r.x, r.y, r.width, r.height);
              }
            }
          } catch(_) {}
          // Lane guides: cyan bottom, yellow top
          try {
            const { ch } = getSize();
            const top = Math.round(ch * (this._roadTopFrac || this.ROAD_TOP_PCT));
            const bot = Math.round(ch * (this._roadBottomFrac || 0.96));
            g.lineStyle(1, 0x00ffff, 0.6);
            g.beginPath(); g.moveTo(0, bot + 0.5); g.lineTo(this.bg.displayWidth || 800, bot + 0.5); g.strokePath();
            g.lineStyle(1, 0xffff00, 0.4);
            g.beginPath(); g.moveTo(0, top + 0.5); g.lineTo(this.bg.displayWidth || 800, top + 0.5); g.strokePath();
          } catch(_) {}
        } else {
          // Clean up graphics if disabled
          if (this._hitG) { try { this._hitG.clear(); this._hitG.destroy(); } catch(_) {} this._hitG = null; }
        }
        
  // Update HUD elements and debug display
  if (this.updateDebug) this.updateDebug();
        document.getElementById('health').innerHTML = this.alex.health;
  document.getElementById('money').innerHTML = Number(this.alex.money||0).toFixed(2);
      }
    }
    
  // Simple overlay scene that pauses the game and listens for resume/mute
    class PauseOverlay extends Phaser.Scene {
      constructor(){ super({ key: 'PauseOverlay' }); }
      create(){
        this._menu = { items: [], idx: 0 };
        const buildUi = () => {
          const w = this.scale.width, h = this.scale.height;
          // Clear previous
          [this.maskRect, this.panel, this.titleText, this.highlight]?.forEach(o => { try { o && o.destroy(); } catch(_){} });
          this._menu.items.forEach(o => { try { o && o.destroy(); } catch(_){} });
          this._menu.items = [];

          // Options
          const baseFont = { fontFamily: 'monospace', fontSize: '22px', color: '#ffffff', align: 'center', stroke:'#000', strokeThickness: 4 };
          const opts = [
            { key: 'resume',  label: 'Resume' },
            { key: 'mute',    label: 'Toggle Music (M)' },
            { key: 'vol',     label: () => `Music Volume: ${Math.round(((this.scene.get('BadenCityRansomGame')?.music?.volume ?? 0.35) * 100))}%` },
            { key: 'restart', label: 'Restart Level' },
            { key: 'quit',    label: 'Quit to Main Menu' }
          ];
          // Measure widest label to auto-size panel
          const meas = (txt) => { const t = this.add.text(0, 0, txt, baseFont).setVisible(false); const mw = t.width; t.destroy(); return mw; };
          const widest = Math.max(...opts.map(o => meas(typeof o.label === 'function' ? o.label() : o.label)), 200);
          const paddingH = 80;
          const pw = Math.min(Math.floor(w * 0.8), Math.max(320, widest + paddingH));
          const lineH = 38;
          const headerH = 70;
          const ph = headerH + (opts.length * lineH) + 32;
          const px = Math.floor((w - pw) / 2), py = Math.floor((h - ph) / 2);

          // Dim background
          this.maskRect = this.add.rectangle(0, 0, w, h, 0x000000, 0.55).setOrigin(0,0).setDepth(10000);
          // Panel
          this.panel = this.add.rectangle(px, py, pw, ph, 0x111133, 0.9)
            .setStrokeStyle(3, 0xffffff, 0.6)
            .setOrigin(0,0).setDepth(10001);
          // Title
          this.titleText = this.add.text(px + pw/2, py + 36, 'Paused', {
            fontFamily: 'monospace', fontSize: '28px', color: '#ffff00', align: 'center', stroke:'#000', strokeThickness: 6
          }).setOrigin(0.5).setDepth(10002);

          // Menu items
          const startY = py + headerH;
          opts.forEach((opt, i) => {
            const label = typeof opt.label === 'function' ? opt.label() : opt.label;
            const t = this.add.text(px + pw/2, startY + i * lineH, label, baseFont)
              .setOrigin(0.5).setDepth(10002).setInteractive({ useHandCursor: true });
            t._optKey = opt.key;
            t.on('pointerover', () => { this._menu.idx = i; this._updateHighlight(); });
            t.on('pointerdown', () => this._activate());
            this._menu.items.push(t);
          });

          // Highlight
          const hiW = Math.floor(pw - 28);
          this.highlight = this.add.rectangle(px + pw/2, startY, hiW, 30, 0xffffff, 0.12)
            .setStrokeStyle(2, 0xffff00, 0.8)
            .setOrigin(0.5).setDepth(10001);

          this._menu.idx = Math.min(this._menu.idx, this._menu.items.length - 1);
          this._updateHighlight();
        };

        this._updateHighlight = () => {
          try {
            const it = this._menu.items[this._menu.idx];
            if (!it || !this.highlight) return;
            this.highlight.x = it.x;
            this.highlight.y = it.y + 2;
          } catch(_) {}
        };

        this._resume = () => { try { this.scene.stop(); this.scene.resume('BadenCityRansomGame'); } catch(err) { console.warn('Error in resume:', err); } };
        this._restart = () => {
          try {
            this.scene.stop('PauseOverlay');
            const gs = this.scene.get('BadenCityRansomGame');
            try { gs?.music?.stop(); } catch(_) {}
            this.scene.stop('BadenCityRansomGame');
            this.scene.start('BadenCityRansomGame');
          } catch(err) { console.warn('Error in restart:', err); }
        };
        this._quit = () => {
          try {
            this.scene.stop('PauseOverlay');
            const gs = this.scene.get('BadenCityRansomGame');
            try { gs?.music?.stop(); } catch(_) {}
            this.sound?.stopAll?.();
            this.scene.stop('BadenCityRansomGame');
            this.scene.start('TitleScene');
          } catch(err) { console.warn('Error in quit:', err); }
        };

        this._activate = () => {
          const it = this._menu.items[this._menu.idx];
          const k = it?._optKey;
          if (k === 'resume') return this._resume();
          if (k === 'mute') { try { const gs = this.scene.get('BadenCityRansomGame'); gs?.toggleMusicMute?.(); } catch(_) {} return; }
          if (k === 'vol') { try { const gs = this.scene.get('BadenCityRansomGame'); gs?.adjustMusicVolume?.(0.02); } catch(_) {} return buildUi(); }
          if (k === 'restart') return this._restart();
          if (k === 'quit') return this._quit();
        };

        this._kbdHandler = (ev) => {
          try {
            if (!ev) return;
            if (ev.code === 'Escape' || ev.code === 'KeyP') return this._resume();
            if (ev.code === 'KeyM') { try { const gs = this.scene.get('BadenCityRansomGame'); gs?.toggleMusicMute?.(); } catch(err) { console.warn('Mute toggle err:', err); } return; }
            if (ev.code === 'ArrowUp')   { this._menu.idx = (this._menu.idx + this._menu.items.length - 1) % this._menu.items.length; this._updateHighlight(); return; }
            if (ev.code === 'ArrowDown') { this._menu.idx = (this._menu.idx + 1) % this._menu.items.length; this._updateHighlight(); return; }
            if (['ArrowLeft','ArrowRight','Home','End','PageUp','PageDown'].includes(ev.code)) {
              const it = this._menu.items[this._menu.idx];
              if (it && it._optKey === 'vol') {
                try {
                  const gs = this.scene.get('BadenCityRansomGame');
                  const delta = ev.code==='ArrowRight' ? 0.02 : ev.code==='ArrowLeft' ? -0.02 : ev.code==='PageUp' ? 0.10 : ev.code==='PageDown' ? -0.10 : 0;
                  if (ev.code==='Home') gs?.adjustMusicVolume?.(-1.0);
                  else if (ev.code==='End') gs?.adjustMusicVolume?.(1.0);
                  else gs?.adjustMusicVolume?.(delta);
                } catch(_) {}
                return buildUi();
              }
            }
            if (ev.code === 'Enter' || ev.code === 'Space') { return this._activate(); }
          } catch(err) { console.warn('KB handler error:', err); }
        };

        buildUi();
        this.scale.on('resize', buildUi, this);
        try { this.input?.keyboard?.on('keydown', this._kbdHandler); } catch(_) {}
      }
      shutdown(){ try { this.scale.off('resize', undefined, this); } catch(_) {} try { this.input?.keyboard?.off('keydown', this._kbdHandler); } catch(_) {} }
      destroy(){ try { this.scale && this.scale.off('resize', undefined, this); } catch(_) {} try { this.input?.keyboard?.off('keydown', this._kbdHandler); } catch(_) {} }
    }
    
    // Minimal Shop overlay
    class ShopOverlay extends Phaser.Scene {
      constructor(){ super({ key: 'ShopOverlay' }); }
      create(){
        const gs = this.scene.get('BadenCityRansomGame');
        const w = this.scale.width, h = this.scale.height;
        const mask = this.add.rectangle(0,0,w,h,0x000000,0.55).setOrigin(0,0).setDepth(10000);
        const panelW = Math.min(420, Math.floor(w*0.9)), panelH = 210;
        const px = Math.floor((w - panelW)/2), py = Math.floor((h - panelH)/2);
        const panel = this.add.rectangle(px,py,panelW,panelH,0x112211,0.92).setOrigin(0,0).setDepth(10001)
          .setStrokeStyle(3, 0xffffff, 0.6);
        const title = this.add.text(px + panelW/2, py+22, 'Shop', { fontFamily:'monospace', fontSize:'24px', color:'#ffffaa', stroke:'#000', strokeThickness:5 }).setOrigin(0.5).setDepth(10002);
        const money = () => Number(gs?.alex?.money||0);
        const line = (i, key, label, cost, hint) => ({ i, key, label, cost, hint });
        const items = [
          line(0,'heal','Apple (Heal 30)', 8, '+30 HP now'),
          line(1,'speed','Sneakers (Speed x1.3, 20s)', 20, 'Run faster briefly'),
        ];
        const rowH = 40; const startY = py + 56;
        const rows = items.map((it, idx) => {
          const y = startY + idx * rowH;
          const txt = this.add.text(px+18, y, `${it.label} - $${it.cost}  ${it.hint?`(${it.hint})`:''}`, { fontFamily:'monospace', fontSize:'18px', color:'#ffffff', stroke:'#000', strokeThickness:4 })
            .setDepth(10002).setInteractive({ useHandCursor:true });
          txt.on('pointerover', ()=> txt.setTint(0xffffaa));
          txt.on('pointerout', ()=> txt.clearTint());
          txt.on('pointerdown', ()=> purchase(it));
          return txt;
        });
        const closeBtn = this.add.text(px+panelW-16, py+panelH-10, 'Close (E/Esc)', { fontFamily:'monospace', fontSize:'14px', color:'#ffffaa', stroke:'#000', strokeThickness:3 })
          .setDepth(10002).setOrigin(1,1).setInteractive({ useHandCursor:true });
        closeBtn.on('pointerdown', ()=> this._close());
        this.input.keyboard?.on('keydown', (ev)=>{ if (ev.code==='Escape' || ev.code==='KeyE') this._close(); });
        this._close = () => { try { this.scene.stop(); this.scene.resume('BadenCityRansomGame'); } catch(_) {} };
        const purchase = (it) => {
          try {
            if (!gs) return;
            const have = money();
            if (have < it.cost) {
              gs.showMessage && gs.showMessage(`Not enough money for ${it.label}.`);
              this.sound && this.sound.play && gs.playSfx && gs.playSfx(['sfx_punch2'], 0.45, 0.9);
              return;
            }
            gs.alex.money = Number((have - it.cost).toFixed(2));
            try { gs.onMoneyChanged && gs.onMoneyChanged(-it.cost); } catch(_) {}
            try { const m=document.getElementById('money'); if (m) m.textContent = Number(gs.alex.money||0).toFixed(2); } catch(_) {}
            if (it.key==='heal') {
              gs.alex.health = Math.min(100, (gs.alex.health||0) + 30);
              gs.showMessage && gs.showMessage('A tasty apple! +30 HP.');
            } else if (it.key==='speed') {
              const now = gs.time.now || performance.now();
              gs.speedBoostUntil = now + 20000; // 20 seconds
              gs.showMessage && gs.showMessage('Sneakers on! Speed up for 20s.');
            }
            this.sound && this.sound.play && gs.playSfx && gs.playSfx(['sfx_jump1'], 0.6, 1.1);
          } catch(_) {}
        };
      }
    }

    // Store interior scene with scrolling shop UI
    class StoreScene extends Phaser.Scene {
      constructor(){ super({ key: 'StoreScene' }); }
      create(data){
        const gs = this.scene.get('BadenCityRansomGame');
        const w = this.scale.width, h = this.scale.height;
  // Dim the street as backdrop (no interior art) — lighten slightly for readability
  const bg = this.add.rectangle(0,0,w,h,0x000000,0.58).setOrigin(0,0).setDepth(1);

        // Polished panel and layout (two-column, highlight, details)
        const panelW = Math.min(620, Math.floor(w*0.92)), panelH = Math.min(420, Math.floor(h*0.86));
        const px = Math.floor((w - panelW)/2), py = Math.floor((h - panelH)/2);
  const panel = this.add.rectangle(px,py,panelW,panelH,0x151e15,0.94).setOrigin(0,0).setDepth(2).setStrokeStyle(2,0xffffff,0.45);
  const header = this.add.rectangle(px, py, panelW, 40, 0x203020, 0.98).setOrigin(0,0).setDepth(3);
  this.add.text(px+14, py+20, 'Store', { fontFamily:'monospace', fontSize:'22px', fontStyle:'bold', color:'#ffffdd', stroke:'#000', strokeThickness:5, resolution: 2 }).setOrigin(0,0.5).setDepth(4);
  const moneyTxt = this.add.text(px+panelW-14, py+20, '', { fontFamily:'monospace', fontSize:'20px', fontStyle:'bold', color:'#e0ffe0', stroke:'#000', strokeThickness:5, resolution: 2 })
          .setOrigin(1,0.5).setDepth(4);
        const fmtMoney = () => `$${Number(gs?.alex?.money||0).toFixed(2)}`;
        const updateMoney = () => moneyTxt.setText(fmtMoney());
        updateMoney();

        // Items model (add light metadata)
        const items = [
          { key:'apple', label:'Apple',      cost:8,  desc:'+30 HP now',          action: () => { gs.alex.health = Math.max(0, Math.min(100, (gs.alex.health||0)+30)); } },
          { key:'ramen', label:'Ramen',      cost:12, desc:'+50 HP',              action: () => { gs.alex.health = Math.max(0, Math.min(100, (gs.alex.health||0)+50)); } },
          { key:'sneak', label:'Sneakers',   cost:20, desc:'Speed x1.3 for 20s',  action: () => { const now = gs.time.now||performance.now(); gs.speedBoostUntil = now + 20000; gs.updateBuffHUD && gs.updateBuffHUD(); } },
          { key:'coinp', label:'Coin Purse', cost:35, desc:'+5% coin value (stack, max +50%)', action: () => { gs.coinValueBonus = Math.min(0.5, (gs.coinValueBonus||0)+0.05); gs.updateBuffHUD && gs.updateBuffHUD(); } },
          { key:'map',   label:'City Map',   cost:10, desc:'Show exits on street', action: () => { gs.cityMapOwned = true; gs.showMessage && gs.showMessage('Map: exits highlighted.'); gs.updateBuffHUD && gs.updateBuffHUD(); } },
        ];

        // Left list area
        const listArea = { x: px+12, y: py+50, w: Math.floor(panelW*0.54), h: panelH - 96 };
        const listBg = this.add.rectangle(listArea.x, listArea.y, listArea.w, listArea.h, 0x162116, 0.9).setOrigin(0,0).setDepth(3)
          .setStrokeStyle(1, 0xffffff, 0.3);
        const rowH = 32; const viewRows = Math.max(4, Math.floor((listArea.h - 10)/rowH));
        let sel = 0, top = 0;
        const highlight = this.add.rectangle(0,0,listArea.w-6,rowH-2,0x2b3c2b,0.92).setOrigin(0,0).setDepth(4).setVisible(false);
        const priceRight = listArea.x + listArea.w - 12;
        const rowNodes = [];

        const affordable = (it) => (Number(gs?.alex?.money||0) >= Number(it.cost||0));
    const drawList = () => {
          // maintain selection within bounds and scroll window
          sel = Phaser.Math.Clamp(sel, 0, items.length-1);
          if (sel < top) top = sel;
          if (sel >= top + viewRows) top = sel - viewRows + 1;
          // clear old
          rowNodes.splice(0).forEach(n=>n.destroy());
          // rows
          for (let i=0;i<viewRows;i++) {
            const idx = top + i; if (idx >= items.length) break;
            const it = items[idx]; const y = listArea.y + 6 + i*rowH;
      const color = idx===sel ? '#ffffcc' : affordable(it) ? '#f8f8ff' : '#b8b8b8';
      const name = this.add.text(listArea.x+8, y, it.label, { fontFamily:'monospace', fontSize:'18px', fontStyle: idx===sel ? 'bold' : 'normal', color, stroke:'#000', strokeThickness:4, resolution: 2 }).setDepth(5).setInteractive({ useHandCursor:true });
      const price = this.add.text(priceRight, y, `$${it.cost}`, { fontFamily:'monospace', fontSize:'18px', fontStyle: idx===sel ? 'bold' : 'normal', color, stroke:'#000', strokeThickness:4, resolution: 2 }).setOrigin(1,0).setDepth(5);
            name.on('pointerover', ()=>{ sel = idx; updateAll(); });
            name.on('pointerdown', ()=>{ sel = idx; updateAll(); });
            rowNodes.push(name, price);
          }
          // highlight position
          if (items[sel]) {
            highlight.setVisible(true);
            const hiY = listArea.y + 6 + (sel - top) * rowH - 2;
            highlight.setPosition(listArea.x+3, hiY);
          } else {
            highlight.setVisible(false);
          }
          // scroll cues
          const moreUp = top > 0, moreDown = (top + viewRows) < items.length;
          // simple triangles
          rowNodes.push(this.add.text(listArea.x + listArea.w/2, listArea.y - 12, moreUp ? '▲' : ' ', { fontFamily:'monospace', fontSize:'12px', color:'#cccccc' }).setOrigin(0.5,1).setDepth(5));
          rowNodes.push(this.add.text(listArea.x + listArea.w/2, listArea.y + listArea.h + 2, moreDown ? '▼' : ' ', { fontFamily:'monospace', fontSize:'12px', color:'#cccccc' }).setOrigin(0.5,0).setDepth(5));
        };

        // Right details area
        const detArea = { x: listArea.x + listArea.w + 12, y: listArea.y, w: panelW - (listArea.w + 12 + 24), h: listArea.h };
        const detBg = this.add.rectangle(detArea.x, detArea.y, detArea.w, detArea.h, 0x162116, 0.9).setOrigin(0,0).setDepth(3)
          .setStrokeStyle(1, 0xffffff, 0.3);
        const detTitle = this.add.text(detArea.x+10, detArea.y+8, '', { fontFamily:'monospace', fontSize:'19px', fontStyle:'bold', color:'#ffffee', stroke:'#000', strokeThickness:5, resolution: 2 }).setDepth(5);
        const detDesc  = this.add.text(detArea.x+10, detArea.y+36, '', { fontFamily:'monospace', fontSize:'16px', color:'#eaffea', wordWrap:{ width: detArea.w-20 }, resolution: 2 }).setDepth(5);
        const feedback = this.add.text(detArea.x+10, detArea.y+detArea.h-48, '', { fontFamily:'monospace', fontSize:'14px', color:'#ffffaa', stroke:'#000', strokeThickness:4, resolution: 2 }).setDepth(5);

        // Buttons row
        const btnY = py + panelH - 16;
  const exitBtn = this.add.text(px+panelW-16, btnY, 'Exit', { fontFamily:'monospace', fontSize:'17px', fontStyle:'bold', color:'#ffffee', stroke:'#000', strokeThickness:4, resolution: 2 }).setOrigin(1,1).setDepth(4).setInteractive({ useHandCursor:true });
  const buyBtn  = this.add.text(px+panelW-100, btnY, 'Buy', { fontFamily:'monospace', fontSize:'17px', fontStyle:'bold', color:'#ffffee', stroke:'#000', strokeThickness:4, resolution: 2 }).setOrigin(1,1).setDepth(4).setInteractive({ useHandCursor:true });

        const updateButtons = () => {
          const it = items[sel]; const can = !!it && affordable(it);
          buyBtn.setAlpha(can ? 1 : 0.6);
          buyBtn.disableInteractive(); if (can) buyBtn.setInteractive({ useHandCursor:true });
        };

        const updateDetails = () => {
          const it = items[sel]; if (!it) { detTitle.setText(''); detDesc.setText(''); feedback.setText(''); updateButtons(); return; }
          detTitle.setText(`${it.label}  —  $${it.cost}`);
          detDesc.setText(it.desc || '');
          const have = Number(gs?.alex?.money||0);
          if (have < it.cost) feedback.setText('Not enough money.'); else feedback.setText('');
          updateButtons();
        };

        const updateAll = () => { drawList(); updateDetails(); updateMoney(); };
        drawList(); updateDetails();

        const attemptBuy = () => {
          try {
            const it = items[sel]; if (!it) return;
            const have = Number(gs?.alex?.money||0);
            if (have < it.cost) { feedback.setText('Not enough money.'); this.sound && gs.playSfx && gs.playSfx(['sfx_punch2'], 0.45, 0.9); return; }
            // pay
            gs.alex.money = Number((have - it.cost).toFixed(2));
            gs.onMoneyChanged && gs.onMoneyChanged(-it.cost);
            const mEl = document.getElementById('money'); if (mEl) mEl.textContent = Number(gs.alex.money||0).toFixed(2);
            // effect
            it.action && it.action();
            feedback.setText(`Purchased ${it.label}!`);
            updateAll();
            this.sound && gs.playSfx && gs.playSfx(['sfx_jump1'], 0.6, 1.1);
          } catch(_) {}
        };

        buyBtn.on('pointerdown', attemptBuy);
        exitBtn.on('pointerdown', ()=> this._exit());
        // Keyboard
        this.input.keyboard?.on('keydown', (ev)=>{
          if (ev.code==='Escape' || ev.code==='KeyE') return this._exit();
          if (ev.code==='ArrowUp')  { sel = (sel + items.length - 1) % items.length; updateAll(); }
          if (ev.code==='ArrowDown'){ sel = (sel + 1) % items.length; updateAll(); }
          if (ev.code==='Enter') attemptBuy();
        });
        // Hints
  this.add.text(px+14, py+panelH-18, 'Arrows: Navigate   Enter: Buy   Esc/E: Exit', { fontFamily:'monospace', fontSize:'13px', color:'#eeeeee', resolution: 2 }).setDepth(4);

        this._exit = () => { try { this.scene.stop(); this.scene.resume('BadenCityRansomGame'); } catch(_) {} };
      }
    }
    
    // Game configuration with adjusted canvas for bigger UI bars
    const config = {
      type: Phaser.AUTO,
      width: 800,
      height: 480, // 80% of a 600 reference height
      parent: 'canvasWrap',
      backgroundColor: '#000000',
  resolution: 1,
  scene: [TitleScene, StoryScene, BadenCityRansomGame, PauseOverlay, ShopOverlay, StoreScene],
      render: {
        pixelArt: true,
        antialias: false,
        roundPixels: true
      },
      scale: {
        mode: Phaser.Scale.RESIZE,
        autoCenter: Phaser.Scale.NO_CENTER,
        parent: 'canvasWrap'
      }
    };
    
  console.log('Starting authentic Baden City Ransom...');
    const game = new Phaser.Game(config);
  // Expose helpers for Dev UI
  window._BCR = { game, gs: () => { try { return game.scene.getScene('BadenCityRansomGame'); } catch(_) { return null; } } };
    
    game.events.on('ready', () => {
      console.log('🎮 BADEN CITY RANSOM IS READY TO PLAY!');
    });
    // Wire Dev UI controls
    (function(){
      const btn = document.getElementById('devBtn');
      const panel = document.getElementById('devPanel');
      const close = document.getElementById('devClose');
      const god = document.getElementById('devGod');
      const boss = document.getElementById('devBoss');
  const bossType = document.getElementById('devBossType');
  const hit = document.getElementById('devHit');
  const addMoneyBtn = document.getElementById('devAddMoney');
      if (!btn || !panel) return;
      const gs = () => (window._BCR && window._BCR.gs) ? window._BCR.gs() : null;
      btn.addEventListener('click', () => {
        const show = panel.style.display !== 'block';
        panel.style.display = show ? 'block' : 'none';
        btn.setAttribute('aria-expanded', String(show));
        // When opening, sync selector to current boss config
        if (show && bossType) {
          try {
            const s = gs();
            const val = s?.currentBossConfig?.key || 'boss';
            bossType.value = val;
    if (hit) hit.checked = !!s?.debugHitboxes;
          } catch(_) {}
        }
      });
      close && close.addEventListener('click', () => {
        panel.style.display = 'none';
        btn.setAttribute('aria-expanded', 'false');
      });
      addMoneyBtn && addMoneyBtn.addEventListener('click', () => {
        const s = gs(); if (!s) return;
        try {
          s.alex.money = Number(((s.alex.money||0) + 5).toFixed(2));
          try { s.onMoneyChanged && s.onMoneyChanged(+5); } catch(_) {}
          const mEl = document.getElementById('money'); if (mEl) mEl.textContent = Number(s.alex.money||0).toFixed(2);
        } catch(_) {}
      });
      god && god.addEventListener('change', () => { const s = gs(); if (s && s.setGodMode) s.setGodMode(god.checked); });
      bossType && bossType.addEventListener('change', async () => {
        const s = gs(); if (!s) return;
        try {
          const choice = bossType.value || 'boss';
          const cfg = (s.bossConfigs||[]).find(c => c.key === choice) || s.bossConfigs?.[0];
          if (cfg) {
            s.currentBossConfig = cfg;
            s.bossName = cfg.name || (choice==='boss2'?'Test Boss':'Miller');
            // If boss currently spawned, respawn as new type
            if (boss && boss.checked) {
              s.despawnBoss && s.despawnBoss();
              // Yield a tick to ensure cleanup
              setTimeout(() => { s.spawnBossNearPlayer && s.spawnBossNearPlayer(); }, 50);
            }
          }
        } catch(_) {}
      });
      hit && hit.addEventListener('change', () => {
        const s = gs(); if (!s) return;
        s.debugHitboxes = !!hit.checked;
        if (!s.debugHitboxes) { try { s._hitG?.clear(); s._hitG?.destroy(); } catch(_) {} s._hitG = null; s._lastPlayerHitRect = null; }
      });
  boss && boss.addEventListener('change', () => { 
        const s = gs(); 
        if (!s) return; 
        
        if (boss.checked) { 
          // Ensure boss spawn with robust error handling
          try {
            console.log('Boss checkbox checked, attempting to spawn');
            
            // Determine target boss type
            const typeSel = document.getElementById('devBossType');
            const pick = typeSel ? typeSel.value : 'boss';
            if (pick === 'boss') {
              // Always clear any existing boss before spawning a new one
              try { s.despawnBoss && s.despawnBoss(); } catch(_) {}
              // Preload Miller image for robustness, then spawn
              const img = new Image();
              img.src = `${window.location.origin}/assets/sprites/boss_sprite.png`;
              img.onload = () => {
                if (s.textures && !s.textures.exists('boss_direct')) {
                  try { s.textures.addImage('boss_direct', img); } catch(e) { console.error('Failed to add texture:', e); }
                }
                if (s.spawnBossNearPlayer) s.spawnBossNearPlayer();
              };
              img.onerror = () => { if (s.spawnBossNearPlayer) s.spawnBossNearPlayer(); };
            } else {
              // Alt boss relies on scene dynamic loader; just call spawn once
              try { s.despawnBoss && s.despawnBoss(); } catch(_) {}
              if (s.spawnBossNearPlayer) s.spawnBossNearPlayer();
            }
            if (s.showMessage) s.showMessage('Spawning boss...');
            
          } catch(e) {
            console.error('Error in boss spawn:', e);
            // Try direct spawn as last resort
            try {
              if (s.spawnBossNearPlayer) s.spawnBossNearPlayer();
            } catch(_) {}
          }
        } else { 
          if (s.despawnBoss) s.despawnBoss(); 
          if (s.showMessage) s.showMessage('Despawn request sent.'); 
        } 
      });
      // Initialize boss checkbox if spawned by default
      setTimeout(() => { const s = gs(); if (s && s.boss) { if (boss) boss.checked = true; } }, 200);
    })();
  })();
  </script>
  <script>
    // Catch unexpected runtime errors early and surface them in the dialogue bar
    (function(){
      const report = (msg) => { const d = document.getElementById('dialogue-text'); if (d) d.textContent = String(msg); };
      window.addEventListener('error', (e) => {
        const parts = [
          'Error:', e?.message,
          e?.filename ? `@ ${e.filename}` : '',
          (e?.lineno||e?.colno) ? `:${e.lineno||0}:${e.colno||0}` : ''
        ].filter(Boolean);
        report(parts.join(' '));
        if (e?.error?.stack) console.error(e.error.stack);
      });
      window.addEventListener('unhandledrejection', (e) => {
        const reason = e?.reason;
        report(`Unhandled: ${reason?.message || reason || 'unknown'}`);
        if (reason?.stack) console.error(reason.stack);
      });
    })();
  </script>
</body>
</html>
