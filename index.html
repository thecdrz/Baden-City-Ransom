<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Baden City Ransom</title>
  <meta http-equiv="refresh" content="0; url=/docs/">
  <link rel="icon" href="data:,">
  <style>
    :root{ --bg:#0b1220; --fg:#e8f0ff; --card:#11182a; --border:#1f2a40; --btn:#1f2a40; }
    html,body{height:100%}
    body{margin:0;display:flex;align-items:center;justify-content:center;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
    .wrap{max-width:820px;padding:28px}
    .card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:22px}
    h1{margin:0 0 10px;font-size:28px}
    p{margin:8px 0 18px;opacity:.92}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .btn{display:inline-block;padding:10px 14px;background:var(--btn);color:var(--fg);border-radius:8px;text-decoration:none}
    .hint{margin-top:10px;font-size:13px;opacity:.8}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Baden City Ransom</h1>
      <p>Redirecting to the website… If nothing happens, use the buttons below.</p>
      <div class="row">
        <a class="btn" href="/docs/">Website</a>
        <a class="btn" href="/game/">Play</a>
        <a class="btn" href="/docs/how-to-play.html">How to Play</a>
      </div>
      <div class="hint">Tip: Bookmark cdrz.app. The Play button launches the in-browser build.</div>
    </div>
  </div>
</body>
</html>
        try {
          const sampleCols = 24;
          const xs = Array.from({length: sampleCols}, (_, i) => Math.floor((i+0.5) * w / sampleCols));
          const isBlueish = (r,g,b) => b > g + 20 && b > r + 20 && b > 80; // strong blue dominance
          for (let y = 0; y < h; y += 2) {
            let blueHits = 0;
            for (const x of xs) {
              const d = ctx.getImageData(x, y, 1, 1).data; // small samples; acceptable at init
              if (isBlueish(d[0], d[1], d[2])) blueHits++;
            }
            if (blueHits >= Math.ceil(sampleCols * 0.6)) {
              return y / h; // fraction from top
            }
          }
        } catch (e) { console.warn('Road detection failed', e); }
        return null;
      };
      // Detect bottom boundary by scanning upward
      const analyzeRoadBottom = (ctx, w, h) => {
        try {
          const sampleCols = 24;
          const xs = Array.from({length: sampleCols}, (_, i) => Math.floor((i+0.5) * w / sampleCols));
          const isBlueish = (r,g,b) => b > g + 20 && b > r + 20 && b > 80;
          for (let y = h - 1; y >= 0; y -= 2) {
            let blueHits = 0;
            for (const x of xs) {
              const d = ctx.getImageData(x, y, 1, 1).data;
              if (isBlueish(d[0], d[1], d[2])) blueHits++;
            }
            if (blueHits >= Math.ceil(sampleCols * 0.6)) {
              return y / h;
            }
          }
        } catch (e) { console.warn('Road bottom detection failed', e); }
        return null;
      };
      const fracTop = analyzeRoadTop(ctx, bgWidth, this._bgCropH);
      const fracBot = analyzeRoadBottom(ctx, bgWidth, this._bgCropH);
      this._roadTopFrac = (fracTop != null ? fracTop : 0.65);
      this._roadBottomFrac = (fracBot != null ? fracBot : 0.96);
      useKey = playKey;
    } else {
      // Fallback to raw image if something’s off
      const raw = this.textures.get('downtown');
      this._bgNaturalW = raw?.source?.[0]?.width || 800;
      this._bgCropH = raw?.source?.[0]?.height || 480;
  this._roadTopFrac = 0.65;
  this._roadBottomFrac = 0.96;
    }
  } catch (e) {
    // Fallback to raw image on any unexpected error
    const raw = this.textures.get('downtown');
    this._bgNaturalW = raw?.source?.[0]?.width || 800;
    this._bgCropH = raw?.source?.[0]?.height || 480;
    useKey = 'downtown';
  this._roadTopFrac = 0.65;
  this._roadBottomFrac = 0.96;
  }

  // Optionally tile the cropped background horizontally to create a long map sized to target minutes
  try {
    if (this.textures.exists('downtown_play')) {
      const src = this.textures.get('downtown_play').getSourceImage();
      const tileW = this._bgNaturalW; // width of the original background
      const tileH = this._bgCropH;    // cropped height
      // Estimate desired world width based on player ground speed (~2 px per frame at 60fps = 120 px/s)
      const { ch } = getSize();
      const scaleForBand = ch / tileH;
      const pxPerSec = 120; // 2 px/frame * 60fps
      const targetSecs = 180; // ~3 minutes walking time (combat will extend total time)
      const targetWorldWidth = pxPerSec * targetSecs; // in scaled world px
      const tilesNeeded = Math.ceil(targetWorldWidth / (tileW * scaleForBand));
      const TILES = Math.max(3, Math.min(40, tilesNeeded));
      const longKey = 'downtown_long';
      if (this.textures.exists(longKey)) this.textures.remove(longKey);
      const longTex = this.textures.createCanvas(longKey, tileW * TILES, tileH);
      const lctx = longTex.getContext(); lctx.imageSmoothingEnabled = false;
      for (let i=0;i<TILES;i++) lctx.drawImage(src, 0, 0, tileW, tileH, i*tileW, 0, tileW, tileH);
      longTex.refresh();
      // swap to long map
      useKey = longKey;
      this._bgNaturalW = tileW * TILES;
    }
  } catch(e) { console.warn('Failed to build long background, using single tile', e); }

  // Use whichever background key we ended up with
  step(`bg add key=${useKey}`);
  if (!this.textures.exists(useKey)) { throw new Error(`Background texture missing: ${useKey}`); }
  this.bg = this.add.image(0, 0, useKey).setOrigin(0, 0);

  // Scale to fill the canvas height (80vh) and center horizontally (robust fallbacks)
  const { cw, ch } = getSize();
  const scale = (this._bgCropH && this._bgCropH > 0) ? (ch / this._bgCropH) : 1;
  this.bg.setScale(scale);
  const displayW = this._bgNaturalW * scale;
  this.bg.x = 0;
  this.bg.y = 0;

  // Set up a side-scrolling camera that follows the player
  const cam = this.cameras.main;
  cam.setRoundPixels(true);
  cam.setBounds(0, 0, displayW, ch);
        
  // console log for debugging is noisy on some hosts; keep quiet in prod
        
  // Player scale relative to background so pixels match
  const pixelScale = this.bg.scaleX;
  const PLAYER_SCALE_MULT = 1.0; // match background pixel size exactly
  const playerScale = pixelScale * PLAYER_SCALE_MULT;

  // Create Alex player positioned near road (feet-origin at y=ch-18 approx)
  step('spawn alex');
  // Prefer the 'alex' spritesheet; if missing, draw a small placeholder so scene still starts
  const PLAYER_TEX = 'alex';
  if (this.textures.exists(PLAYER_TEX)) {
    this.alex = this.add.sprite(200, ch - 18, PLAYER_TEX, 0).setOrigin(0.5, 1);
  } else {
    // Minimal placeholder rectangle so we never crash on missing asset
    const phKey = 'player_placeholder';
    if (!this.textures.exists(phKey)) {
      const t = this.textures.createCanvas(phKey, 16, 32);
      const c = t.getContext();
      c.fillStyle = '#ff6b6b'; c.fillRect(0,0,16,32);
      c.strokeStyle = '#000'; c.lineWidth = 2; c.strokeRect(1,1,14,30);
      t.refresh();
    }
    this.alex = this.add.image(200, ch - 18, phKey).setOrigin(0.5, 1);
  }
    this.alex.setScale(playerScale);
  // Camera follows the player for smooth scrolling
  this.cameras.main.startFollow(this.alex, true, 0.12, 0.12);
        // Normalize scale baseline
        this._playerScaleAdjust = 1.0;
        this.alex.health = 100;
  this.alex.money = 4.20; // New default
        
        // Create enemy gang members
  step('spawn enemies');
  this.enemies = [];
        // Focus on a single enemy for tight combat iteration
        const enemyType = 'enemy1';
        console.log(`Available textures:`, Object.keys(this.textures.list));
        console.log(`Looking for enemy texture: ${enemyType}, exists: ${this.textures.exists(enemyType)}`);
        if (this.textures.exists(enemyType)) {
          const ex = Math.max(420, Math.min(displayW - 160, 700));
          const enemy = this.add.sprite(ex, ch - 18, enemyType, 0).setOrigin(0.5, 1);
          enemy.setScale(playerScale);
          enemy.health = 60;
          enemy.type = enemyType;
          enemy.aiTimer = 0;
          enemy.speed = 0.9;
          enemy.attackCooldown = 0; // ms
          enemy.attackCadence = 900; // ms between attacks
          enemy.attackReach = 24; // horizontal reach
          enemy.attackWidth = 20;
          enemy.attackHeight = 18;
          this.enemies.push(enemy);
          console.log(`Enemy spawned at (${ex}, ${ch - 18}) with properties:`, {
            health: enemy.health, 
            type: enemy.type, 
            attackReach: enemy.attackReach,
            attackWidth: enemy.attackWidth,
            attackHeight: enemy.attackHeight
          });
        } else {
          console.log(`Enemy texture '${enemyType}' not found!`);
        }
  // Boss is spawned manually via Dev tools or future triggers
  step('boss (manual spawn)');
  this.bossName = 'Miller';
  this.boss = null;
  try { const cb = document.getElementById('devBoss'); if (cb) cb.checked = false; } catch(_) {}
        
        // Create Alex animations using heuristic row/column ranges with URL override support
  step('anims');
  const SHEET = { fw:16, fh:32, margin:1, spacing:1 };
  const baseTexKey = this.textures.exists('alex') ? 'alex' : null;
  const alexImg = baseTexKey ? this.textures.get(baseTexKey).source?.[0] : null;
  const sheetW = alexImg?.width || 0;
  const sheetH = alexImg?.height || 0;
  // Derive frames-per-row/col exactly like Phaser's spritesheet parser: (size - 2*margin + spacing) / (frame + spacing)
  const cols = sheetW ? Math.max(1, Math.floor((sheetW - (SHEET.margin*2) + SHEET.spacing) / (SHEET.fw + SHEET.spacing))) : 8;
  const rows = sheetH ? Math.max(1, Math.floor((sheetH - (SHEET.margin*2) + SHEET.spacing) / (SHEET.fh + SHEET.spacing))) : 6;
  const idx = (r,c) => (Math.max(0, Math.min(rows-1, r)) * cols) + Math.max(0, Math.min(cols-1, c));
  const parseMap = () => {
    const params = new URLSearchParams(location.search);
    const raw = params.get('alexMap'); // e.g., walk=0:0-1;punch=1:0-2;kick=2:0-2;jump=3:0-1
    if (!raw) return null;
    const out = {};
    raw.split(';').forEach(part => {
      const [k, spec] = part.split('=');
      if (!k || !spec) return;
      const [rowStr, colsStr] = spec.split(':');
      const r = parseInt(rowStr, 10);
      const [a,b] = (colsStr||'0-0').split('-').map(x=>parseInt(x,10));
      out[k.trim()] = { row: isNaN(r)?0:r, from: isNaN(a)?0:a, to: isNaN(b)?a:b };
    });
    return out;
  };
  const map = parseMap() || {
    // Defaults matching prior working setup
    walk:  { row: 0, from: 0, to: Math.min(1, cols-1) },
    punch: { row: 1, from: 0, to: Math.min(2, cols-1) },
    // Kick provisional (will auto-tune below)
    kick:  { row: 2, from: 0, to: Math.min(2, cols-1) },
    // Jump left as-is since you’re happy with it
    jump:  { row: 0, from: 0, to: 0 }
  };

  // Auto-select a non-ducking kick row by scanning pixels (if no explicit URL override)
  (function autoPickKickRow(){
    const hasOverride = new URLSearchParams(location.search).get('alexMap');
    if (hasOverride) return; // user-specified mapping wins
    try {
      if (!baseTexKey) return;
      const tex = this.textures.get(baseTexKey);
      const src = tex.getSourceImage();
      if (!src) return;
      const tmp = document.createElement('canvas');
      const ctx = tmp.getContext('2d', { willReadFrequently: true });
      const heightScores = [];
      const scoreRow = (r) => {
        // sample first 3 columns on this row
        let heights = [];
        for (let c = 0; c < Math.min(3, cols); c++) {
          const fIdx = idx(r, c);
          const f = this.textures.getFrame(baseTexKey, fIdx);
          if (!f) continue;
          tmp.width = f.cutWidth; tmp.height = f.cutHeight;
          ctx.clearRect(0,0,tmp.width,tmp.height);
          ctx.drawImage(f.source.image, f.cutX, f.cutY, f.cutWidth, f.cutHeight, 0, 0, f.cutWidth, f.cutHeight);
          const data = ctx.getImageData(0,0,tmp.width,tmp.height).data;
          // compute alpha bbox
          let top = tmp.height, bottom = -1;
          for (let y=0; y<tmp.height; y++) {
            for (let x=0; x<tmp.width; x++) {
              const a = data[(y*tmp.width + x)*4 + 3];
              if (a > 8) { if (y < top) top = y; if (y > bottom) bottom = y; }
            }
          }
          if (bottom >= top) heights.push(bottom - top + 1);
        }
        if (!heights.length) return 0;
        heights.sort((a,b)=>a-b); const mid = heights[Math.floor(heights.length/2)];
        return mid || 0;
      };
      for (let r=0;r<rows;r++) {
        // skip rows already used by walk or punch
        if (r === map.walk.row || r === map.punch.row) continue;
        heightScores.push({ r, h: scoreRow(r) });
      }
      // prefer taller rows (avoid crouch/duck which are short)
      heightScores.sort((a,b)=>b.h - a.h);
      const best = heightScores.find(s => s.h >= 24) || heightScores[0];
      if (best && Number.isFinite(best.r)) {
        map.kick.row = best.r;
        console.log('Auto-picked kick row', best);
      }
    } catch(e) { console.warn('autoPickKickRow failed', e); }
  }).call(this);
  // Build trimmed textures for used frames to remove deadspace
  const usedIdx = new Set();
  const addRange = (m) => { if (!m) return; for (let c=m.from; c<=m.to; c++) usedIdx.add(idx(m.row, c)); };
  addRange(map.walk); addRange(map.punch); addRange(map.kick); usedIdx.add(idx(map.jump.row, map.jump.from));
  const trimKeyOf = (fIndex) => `alex_t_${fIndex}`;
  try {
    const tmp = document.createElement('canvas');
    const ctx = tmp.getContext('2d', { willReadFrequently: true });
    usedIdx.forEach(fIndex => {
      if (!baseTexKey) return;
      const f = this.textures.getFrame(baseTexKey, fIndex);
      if (!f) return;
      tmp.width = f.cutWidth; tmp.height = f.cutHeight;
      ctx.clearRect(0,0,tmp.width,tmp.height);
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(f.source.image, f.cutX, f.cutY, f.cutWidth, f.cutHeight, 0, 0, f.cutWidth, f.cutHeight);
  // Convert magenta/purple backgrounds to transparent (simplified and optimized)
      const img = ctx.getImageData(0,0,tmp.width,tmp.height);
      const data = img.data;
      for (let p=0; p<data.length; p+=4) {
        const r=data[p], g=data[p+1], b=data[p+2], a=data[p+3];
        if (a > 0) {
      // Magenta/purple color key detection (most common in NES sprites)
      if ((r>200 && g<110 && b>200) || (r>240 && g<20 && b>240) || (g < 40 && r > 120 && b > 120 && Math.abs(r-b) < 60)) {
            data[p+3] = 0; // Make transparent
          }
        }
      }
  const padBottom = 8; // more bottom padding to keep Alex's feet visible
      ctx.putImageData(img, 0, 0);
      let minX=tmp.width, minY=tmp.height, maxX=-1, maxY=-1;
      for (let y=0;y<tmp.height;y++) {
        for (let x=0;x<tmp.width;x++) {
          const a = data[(y*tmp.width + x)*4 + 3];
          if (a>8) { if (x<minX) minX=x; if (y<minY) minY=y; if (x>maxX) maxX=x; if (y>maxY) maxY=y; }
        }
      }
      if (maxX<minX || maxY<minY) { // fully empty? create tiny transparent
        minX=0; minY=0; maxX=1; maxY=1;
      }
  const w = Math.max(1, maxX-minX+1);
  const h = Math.max(1, maxY-minY+1);
      // Create a canvas texture per frame
      const key = trimKeyOf(fIndex);
      if (this.textures.exists(key)) this.textures.remove(key);
      const ct = this.textures.createCanvas(key, w, h + padBottom);
      const c2 = ct.getContext();
      c2.imageSmoothingEnabled = false;
      c2.clearRect(0,0,w,h+padBottom);
      c2.drawImage(tmp, minX, minY, w, h, 0, 0, w, h);
      ct.refresh();
    });
  } catch(e) { console.warn('Trimming frames failed', e); }

  const range = (k) => {
    const m = map[k]; if (!m) return [{ key: 'alex', frame: 0 }];
    const frames = [];
    for (let c=m.from; c<=m.to; c++) {
      const fIndex = idx(m.row, c);
      const tKey = trimKeyOf(fIndex);
      if (this.textures.exists(tKey)) frames.push({ key: tKey, frame: 0 });
      else frames.push({ key: baseTexKey || 'alex', frame: fIndex });
    }
    return frames.length?frames:[{ key: baseTexKey || 'alex', frame: 0 }];
  };
  if (baseTexKey) {
    const idleIndex = idx(map.walk.row, map.walk.from);
    const idleTrimKey = trimKeyOf(idleIndex);
    const idleFrames = this.textures.exists(idleTrimKey) ? [{ key: idleTrimKey, frame: 0 }] : [{ key: baseTexKey, frame: idleIndex }];
    this.anims.create({ key: 'alex-idle', frames: idleFrames, frameRate: 1, repeat: -1 });
  }
  this.anims.create({ key: 'alex-walk', frames: range('walk'), frameRate: 8, repeat: -1 });
  // Run uses the same frames as walk but faster
  this.anims.create({ key: 'alex-run', frames: range('walk'), frameRate: 14, repeat: -1 });
  this.anims.create({ key: 'alex-punch', frames: range('punch'), frameRate: 10, repeat: 0 });
  this.anims.create({ key: 'alex-kick',  frames: range('kick'),  frameRate: 10, repeat: 0 });
  // Jump: a single stable airborne frame; no yoyo to avoid odd flicker
  {
    const jIndex = idx(map.jump.row, map.jump.from);
    const tKey = trimKeyOf(jIndex);
    const jf = this.textures.exists(tKey) ? [{ key: tKey, frame: 0 }] : (baseTexKey ? [{ key: baseTexKey, frame: jIndex }] : [{ key: 'alex', frame: 0 }]);
    if (baseTexKey) this.anims.create({ key: 'alex-jump', frames: jf, frameRate: 1, repeat: -1 });
  }
        
        // Create enemy animations for each type - simplified
    const enemyAnimTypes = ['enemy1', 'enemy2', 'enemy3'];
  enemyAnimTypes.forEach(enemyType => {
          if (this.textures.exists(enemyType)) {
            this.anims.create({
              key: `${enemyType}-idle`,
              frames: [{ key: enemyType, frame: 0 }],
              frameRate: 1,
              repeat: 0
            });
            
            this.anims.create({
              key: `${enemyType}-walk`,
              frames: [{ key: enemyType, frame: 0 }, { key: enemyType, frame: 1 }],
              frameRate: 6,
              repeat: -1
            });
          }
        });
  // Boss animations (use trimmed frames for tighter bounds if possible)
  // Use the base 'boss' spritesheet frames directly to avoid any missing trimmed textures
  try {
    this.anims.create({ key: 'boss-idle', frames: [{ key: 'boss', frame: 0 }], frameRate: 1, repeat: -1 });
    this.anims.create({ key: 'boss-walk', frames: [{ key: 'boss', frame: 0 }, { key: 'boss', frame: 1 }], frameRate: 6, repeat: -1 });
    this.anims.create({ key: 'boss-attack', frames: [{ key: 'boss', frame: 1 }, { key: 'boss', frame: 0 }, { key: 'boss', frame: 1 }], frameRate: 14, repeat: 0 });
  } catch(_) {}
        
        // Start animations
  this.alex.play('alex-idle');
        this.enemies.forEach(enemy => {
          enemy.play(`${enemy.type}-idle`);
        });
  if (this.boss) this.boss.play('boss-idle');
        
        // Input setup
  step('input');
  this.cursors = this.input.keyboard.createCursorKeys();
        this.keys = this.input.keyboard.addKeys('A,S,D,SPACE');
  // Dev: quick spawn with B key
  try { this.keys.B = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.B); } catch(_) {}
        // Pause / Mute keys
        const KC = Phaser.Input.Keyboard.KeyCodes;
        this.pauseKeys = {
          esc: this.input.keyboard.addKey(KC.ESC),
          p: this.input.keyboard.addKey(KC.P),
          m: this.input.keyboard.addKey(KC.M)
        };
  // Dev flags and helpers
        this.godMode = false;
        this.setGodMode = (on) => { this.godMode = !!on; this.showMessage(this.godMode ? 'God Mode: ON' : 'God Mode: OFF'); };
  // Hitbox debug drawing
        this.debugHitboxes = false;
        this.hitGfx = this.add.graphics().setDepth(12000).setScrollFactor(1,1).setVisible(false);
        this.setHitboxDebug = (on) => {
          this.debugHitboxes = !!on;
          if (this.hitGfx) { this.hitGfx.clear(); this.hitGfx.setVisible(this.debugHitboxes); }
          this.showMessage(this.debugHitboxes ? 'Hitbox debug: ON' : 'Hitbox debug: OFF');
        };
  // Verbose logging toggle
  this.debugLogs = false;
  this.setVerboseLogs = (on) => { this.debugLogs = !!on; this.showMessage(this.debugLogs ? 'Verbose logs: ON' : 'Verbose logs: OFF'); };
        // Boss health bar toggle and gfx
        this.showBossHP = false;
        this._bossHpGfx = this.add.graphics().setDepth(11000).setScrollFactor(0,0).setVisible(false);
        this.setShowBossHP = (on) => {
          this.showBossHP = !!on;
          this._bossHpGfx.setVisible(this.showBossHP);
          this.showMessage(this.showBossHP ? 'Boss HP: ON' : 'Boss HP: OFF');
        };
    this.spawnBossNearPlayer = () => {
          try {
            // If already present, keep it and inform
            if (this.boss && this.boss.active && !this.boss._defeated) { this.showMessage('Boss already present.'); return this.boss; }
            // Pick a sprite key that exists (fallback to enemy1 if boss sheet missing)
            const spriteKey = this.textures.exists('boss') ? 'boss' : (this.textures.exists('enemy1') ? 'enemy1' : null);
            const bx = Math.max((this.alex?.x || 200) + 70, 60);
            // Fallback ground if baseY not initialized yet
            const groundY = Number.isFinite(this.baseYMax) ? this.baseYMax : ((this.scale.height || this.scale.gameSize?.height || 480) - 18);
            const by = groundY;
            if (!spriteKey) {
              this.showMessage('Boss sprite not loaded (check 404s). No spawn.');
              try { const cb = document.getElementById('devBoss'); if (cb) cb.checked = false; } catch(_) {}
              return null;
            }
            // Use exact groundY as bottom anchor to avoid sinking or clipping feet
            const boss = this.add.sprite(bx, by, spriteKey, 0).setOrigin(0.5, 1).setDepth(10);
            // Force visibility in case any prior alpha/visible flag leaked
            try { boss.setVisible(true); boss.setAlpha(1); } catch(_) {}
            const enemyScale = this.bg?.scaleX || 1;
            boss.setScale(enemyScale);
            boss.health = 140; boss.type = spriteKey; boss.speed = 0.8; boss.attackCooldown = 0; boss.attackCadence = 850; boss.attackReach = 150; boss.attackWidth = 60; boss.attackHeight = 40;
            const animKey = spriteKey === 'boss' ? 'boss-idle' : `${spriteKey}-idle`;
            try { boss.play(animKey); } catch(_) {}
            this.bossName = this.bossName || 'Miller';
            this.boss = boss;
            // Remove spawn flash tint to avoid rare solid-rectangle artifacts on some renderers
            try { boss.clearTint(); boss.setBlendMode(Phaser.BlendModes.NORMAL); } catch(_) {}
            this.showMessage(`${this.bossName} spawned nearby.`);
            // Auto-enable Boss HP bar for clarity during testing
            try { this.setShowBossHP && this.setShowBossHP(true); } catch(_) {}
            // Reflect in Dev UI if present
            try { const cb = document.getElementById('devBoss'); if (cb) cb.checked = true; } catch(_) {}
            return boss;
          } catch(_) { return null; }
        };
        this.despawnBoss = () => {
          try {
            if (this.boss) {
              this.boss.destroy();
              this.boss = null;
              // Auto-hide boss HP bar when boss is gone
              try { this.setShowBossHP && this.setShowBossHP(false); } catch(_) {}
              // Reflect in Dev UI if present
              try {
                const bossCb = document.getElementById('devBoss');
                if (bossCb) bossCb.checked = false;
                const hpCb = document.getElementById('devBossHP');
                if (hpCb) hpCb.checked = false;
              } catch(_) {}
              this.showMessage('Boss despawned.');
            }
          } catch(_) {}
        };
        
  // Game state
  this.isMoving = false;
  this.isAttacking = false;
  // Double-tap to run state
  this.runState = { isRunning:false, dir:0, lastTap:{ left:0, right:0 }, threshold: 280 };
  // Lane movement + jump physics (jump height separate from lane Y)
  // Constrain to detected road band; fallback to constant if detection unavailable
  this.ROAD_TOP_PCT = 0.65;
  // Constrain to detected road band at start as well
  const roadTop0 = Math.round(ch * (this._roadTopFrac || this.ROAD_TOP_PCT));
  const roadBot0 = Math.round(ch * (this._roadBottomFrac || 0.96));
  this.baseYMin = roadTop0 + 10;
  this.baseYMax = Math.max(roadTop0 + 20, Math.min(ch - 8, roadBot0 - 6));
  this.alexBaseY = this.baseYMax;
  this.alexJumpZ = 0; // negative while rising
  this.alexVy = 0;
  this.GRAVITY = 0.28; // slightly slower fall for longer airtime
  this.JUMP_VELOCITY = -12.0; // slightly softer takeoff
  this.alex.y = Math.round(this.alexBaseY + this.alexJumpZ);
  // Player hurt / invulnerability window
  this.playerInvulUntil = 0; // timestamp in ms
  // Active player attack window (keeps hitbox live briefly for reliable hits)
  this._attackWindow = null; // { kind, reach, w, h, startAt, until, hit:Set<object> }
        
  console.log('Baden City Ransom scene ready. Background cropped to road.');
  // Lightweight on-screen debug overlay (updates on resize)
  const dbg = this.add.text(6, 6, '', { fontFamily: 'monospace', fontSize: '12px', color: '#0f0' }).setDepth(10000).setScrollFactor(0);
  const updateDebug = () => {
    const s = [
      `cw:${this.scale.width} ch:${this.scale.height}`,
      `bgKey:${useKey} bgScale:${this.bg.scaleX.toFixed(2)}`,
      `parallax:${Math.round(this._parallaxX)}`,
      `alex:${Math.round(this.alex.x)},${Math.round(this.alex.y)} run:${this.runState?.isRunning?'Y':'N'}`,
      `sheet ${cols}x${rows}  map w:${map.walk.row}:${map.walk.from}-${map.walk.to} p:${map.punch.row}:${map.punch.from}-${map.punch.to} k:${map.kick.row}:${map.kick.from}-${map.kick.to} j:${map.jump.row}:${map.jump.from}-${map.jump.to}`
    ].join('  ');
    dbg.setText(s);
  };
  updateDebug();
        
        // Ensure background continues to fit if the canvas size changes
        this.scale.on('resize', (gameSize) => {
          const w = gameSize?.width || this.scale.width || this.scale.gameSize?.width || canvasWrap?.clientWidth || 800;
          const h = gameSize?.height || this.scale.height || this.scale.gameSize?.height || canvasWrap?.clientHeight || 480;
          applyResize(w, h);
          updateDebug();
        });
        // Apply a couple of staged resizes to settle layout after the Title height swap
        const s0 = getSize();
        applyResize(s0.cw, s0.ch);
        try {
          this.time.delayedCall(16, () => { const s = getSize(); applyResize(s.cw, s.ch); updateDebug(); });
          this.time.delayedCall(80, () => { const s = getSize(); applyResize(s.cw, s.ch); updateDebug(); });
        } catch(_) {}
  // Play authentic street music for this outdoor level
  step('music');
        this.sound.stopAll();
        this.music = this.sound.add('street_music', { loop: true, volume: 0.35 });
        const startMusic = () => { if (!this.music.isPlaying) this.music.play(); };
        if (this.sound.locked) {
          this.sound.once('unlocked', startMusic);
          this.input.once('pointerdown', startMusic);
        } else {
          startMusic();
        }
  // Auto-pause and resume music based on scene pause/resume
  this.events.on('pause', () => { try { this.music?.pause(); } catch(_) {} });
  this.events.on('resume', () => { try { this.music?.resume(); } catch(_) {} });
        // Small helper to play short SFX with minimal overlap
        this._sfxGateTs = 0;
        this.playSfx = (keys, volume=0.5, rate=1.0, duckMs=120, duckVol=0.25) => {
          try {
            if (this.sound.locked) return; // should be unlocked after title
            const now = this.time.now || 0;
            if (now - (this._sfxGateTs||0) < 40) return; // gentle spam gate
            this._sfxGateTs = now;
            const list = Array.isArray(keys) ? keys : [keys];
            const key = list[(Math.random()*list.length)|0];
            if (!this.sound?.get(key)) { /* okay */ }
            const s = this.sound.add(key, { volume, rate });
            s.once('complete', () => s.destroy());
            // Brief music ducking while SFX plays
            const prevVol = this.music?.volume ?? 0.35;
            if (this.music && duckMs>0) {
              this.music.setVolume(Math.max(0, Math.min(prevVol, duckVol)));
              this.time.delayedCall(duckMs, () => { if (this.music) this.music.setVolume(prevVol); });
            }
            s.play();
          } catch (_) { /* ignore */ }
        };
        // Lightweight synthesized SFX (no asset needed)
        this.synth = {
          click: (freq=1100, dur=0.035, vol=0.12) => {
            try {
              const ctx = this.sound.context; const t = ctx.currentTime;
              const o = ctx.createOscillator(); const g = ctx.createGain();
              o.type = 'square'; o.frequency.setValueAtTime(freq, t);
              g.gain.setValueAtTime(0.0001, t);
              g.gain.linearRampToValueAtTime(vol, t + 0.006);
              g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
              o.connect(g).connect(ctx.destination);
              o.start(t); o.stop(t + dur + 0.01);
            } catch(_) {}
          },
          thump: (freq=90, dur=0.12, vol=0.22) => {
            try {
              const ctx = this.sound.context; const t = ctx.currentTime;
              const o = ctx.createOscillator(); const g = ctx.createGain(); const f = ctx.createBiquadFilter();
              o.type = 'sine'; o.frequency.setValueAtTime(freq, t);
              f.type = 'lowpass'; f.frequency.setValueAtTime(240, t);
              g.gain.setValueAtTime(0.0001, t);
              g.gain.linearRampToValueAtTime(vol, t + 0.01);
              g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
              o.connect(f).connect(g).connect(ctx.destination);
              o.start(t); o.stop(t + dur + 0.02);
            } catch(_) {}
          }
        };
        
        // Function to show messages in dialogue bar
        this.showMessage = (text) => {
          document.getElementById('dialogue-text').innerHTML = text;
        };
        // Expose simple toggles for PauseOverlay to call
        this.toggleMusicMute = () => {
          try { if (this.music) { this.music.setMute(!this.music.mute); this.showMessage(this.music.mute ? 'Music muted' : 'Music unmuted'); } } catch(_) {}
        };
        this.enterPause = () => {
          try {
            if (!this.scene.isActive('PauseOverlay')) {
              this.scene.launch('PauseOverlay');
              this.scene.pause();
            }
          } catch(_) {}
        };
        
  this.showMessage('Welcome to Baden City! Fight your way through the gangs!');
  step('ready');
        } catch (err) {
          console.error(err);
          diag(`Init error: ${err?.message || err}`);
          // Do not rethrow to avoid opaque 'Script error.' from cross-origin contexts
          return;
        }
      }
      
      update(time) {
        // Hitbox gfx maintenance
        if (this.hitGfx && this.debugHitboxes) {
          try {
            this.hitGfx.clear();
            // Player bounds in green
            const pb = this.alex.getBounds();
            this.hitGfx.lineStyle(1, 0x00ff00, 0.9);
            this.hitGfx.strokeRect(pb.x, pb.y, pb.width, pb.height);
            // Enemies in red
            (this.enemies||[]).forEach(e => {
              if (!e || !e.active) return;
              const eb = e.getBounds();
              this.hitGfx.lineStyle(1, 0xff4444, 0.9);
              this.hitGfx.strokeRect(eb.x, eb.y, eb.width, eb.height);
            });
            // Boss in magenta
            if (this.boss && this.boss.active) {
              const bb = this.boss.getBounds();
              this.hitGfx.lineStyle(1, 0xff00ff, 0.95);
              this.hitGfx.strokeRect(bb.x, bb.y, bb.width, bb.height);
            }
          } catch(_) {}
        }
        // Pause toggle
        if (Phaser.Input.Keyboard.JustDown(this.pauseKeys.esc) || Phaser.Input.Keyboard.JustDown(this.pauseKeys.p)) {
          this.enterPause();
          return; // stop processing this frame
        }
        // Music mute toggle
        if (Phaser.Input.Keyboard.JustDown(this.pauseKeys.m)) {
          this.toggleMusicMute();
        }
        // Dev: quick boss spawn
        if (this.keys?.B && Phaser.Input.Keyboard.JustDown(this.keys.B)) {
          this.spawnBossNearPlayer && this.spawnBossNearPlayer();
        }
        // Alex movement with double-tap run
        let moving = false;
        const now = time;
        // detect taps
        const tap = (side) => {
          const last = this.runState.lastTap[side] || 0;
          const dt = now - last;
          this.runState.lastTap[side] = now;
          if (dt > 0 && dt < this.runState.threshold) {
            this.runState.isRunning = true;
            this.runState.dir = (side==='left'?-1:1);
          }
        };
        if (Phaser.Input.Keyboard.JustDown(this.cursors.left)) tap('left');
        if (Phaser.Input.Keyboard.JustDown(this.cursors.right)) tap('right');

  const baseSpeed = 2;
        const speed = (this.runState.isRunning ? 3.8 : baseSpeed);

        if (!this.isAttacking && this.cursors.left.isDown) {
          this.alex.x -= speed;
          this.alex.setFlipX(true);
          moving = true;
          if (this.runState.isRunning && this.runState.dir !== -1) this.runState.isRunning = false;
        } else if (!this.isAttacking && this.cursors.right.isDown) {
          this.alex.x += speed;
          this.alex.setFlipX(false);
          moving = true;
          if (this.runState.isRunning && this.runState.dir !== 1) this.runState.isRunning = false;
        } else {
          // No horizontal input: stop running
          this.runState.isRunning = false;
        }
        
        // Lane up/down movement along the road
  if (!this.isAttacking && this.cursors.up.isDown) { this.alexBaseY -= speed; moving = true; }
  else if (!this.isAttacking && this.cursors.down.isDown) { this.alexBaseY += speed; moving = true; }
        this.alexBaseY = Phaser.Math.Clamp(this.alexBaseY, this.baseYMin, this.baseYMax);

        // Jump with D if not already airborne
        const onGround = this.alexJumpZ === 0;
  if (!this.isAttacking && Phaser.Input.Keyboard.JustDown(this.keys.D) && onGround) {
          this.alexVy = this.JUMP_VELOCITY;
          // Play one of the short jump SFX
          this.playSfx(['sfx_jump1','sfx_jump2'], 0.45, 1.0);
        }
        // Apply jump gravity to jump height only
        const wasAir = !onGround || this.alexVy !== 0;
        if (!onGround || this.alexVy !== 0) {
          this.alexJumpZ += this.alexVy;
          this.alexVy += this.GRAVITY;
          if (this.alexJumpZ >= 0) { this.alexJumpZ = 0; this.alexVy = 0; }
        }
        // Compose final render Y
        this.alex.y = Math.round(this.alexBaseY + this.alexJumpZ);
        // Boss health bar render (screen-space)
        if (this._bossHpGfx) {
          try {
            this._bossHpGfx.clear();
            if (this.showBossHP && this.boss && this.boss.active && !this.boss._defeated) {
              const w = this.scale.width || 800;
              const x = 12, y = (this.scale.height || 480) - 28, bw = Math.max(180, Math.min(320, Math.floor(w*0.35))), bh = 12;
              const hp = Math.max(0, Math.min(1, (this.boss.health||0) / 140));
              this._bossHpGfx.fillStyle(0x000000, 0.6).fillRect(x-2, y-2, bw+4, bh+4);
              this._bossHpGfx.fillStyle(0x552222, 1).fillRect(x, y, bw, bh);
              const color = hp > 0.5 ? 0x00dd66 : (hp > 0.25 ? 0xffcc33 : 0xff3344);
              this._bossHpGfx.fillStyle(color, 1).fillRect(x, y, Math.floor(bw*hp), bh);
              // Label
              this._bossHpGfx.lineStyle(1, 0xffffff, 0.9).strokeRect(x, y, bw, bh);
            }
          } catch(_) {}
        }
        // Landing detect: transitioning from air to ground this frame
        const nowOnGround = (this.alexJumpZ === 0 && this.alexVy === 0);
        if (wasAir && nowOnGround) {
          this.synth.thump(95, 0.1, 0.18);
        }
        
  // Animation handling
        if (!onGround && !this.isAttacking) {
          if (this.alex.anims.currentAnim?.key !== 'alex-jump') {
            this.alex.play('alex-jump');
          }
        } else if (moving && !this.isAttacking) {
          const want = this.runState.isRunning ? 'alex-run' : 'alex-walk';
          if (this.alex.anims.currentAnim?.key !== want) this.alex.play(want);
        } else if (!this.isAttacking) {
          if (this.alex.anims.currentAnim?.key !== 'alex-idle') {
            this.alex.play('alex-idle');
          }
        }
        
        // Maintain an active attack window so hits can land during the swing
        if (this._attackWindow) {
          const aw = this._attackWindow;
          const nowTs = this.time.now || time || 0;
          if (nowTs > (aw.until || 0)) {
            // Window expired
            this._attackWindow = null;
          } else if (nowTs >= (aw.startAt || 0)) {
            // Dynamic hitbox based on current player pose
            const ox = this.alex.flipX ? -aw.reach : aw.reach;
            const rect = new Phaser.Geom.Rectangle(this.alex.x + ox - aw.w/2, this.alex.y - aw.h - 6, aw.w, aw.h);
            // Optional debug draw of the live attack rect
            if (this.debugHitboxes && this.hitGfx) {
              try { this.hitGfx.lineStyle(1, 0xffff00, 0.9); this.hitGfx.strokeRect(rect.x, rect.y, rect.width, rect.height); } catch(_) {}
            }
            const tryApply = (target) => {
              if (!target || !target.active) return false;
              if (!aw.hit) aw.hit = new Set();
              if (aw.hit.has(target)) return false; // already hit during this window
              const tb = (typeof target.getBounds === 'function') ? target.getBounds() : null;
              const hitOk = tb ? Phaser.Geom.Intersects.RectangleToRectangle(rect, tb) : false;
              const reach = aw.reach, w = aw.w;
              const dx = Math.abs((target.x||0) - (this.alex.x + (this.alex.flipX ? -reach : reach)));
              const dy = Math.abs((this.alex.y||0) - (target.y||0));
              const nearOk = (dx <= (reach + w*0.9) && dy <= 28);
              if (hitOk || nearOk) {
                const dmg = aw.kind === 'kick' ? 20 : 14;
                const knock = aw.kind === 'kick' ? 8 : 6;
                target.health = Math.max(0, (target.health||1) - dmg);
                try { target.setTintFill(0xff0000); this.time.delayedCall(80, () => target.clearTint()); } catch(_) {}
                target.x += this.alex.flipX ? -knock : knock;
                this.synth && this.synth.click && this.synth.click(1300, 0.03, 0.10);
                this._recentHitUntil = (this.time.now||0) + 140;
                if (target.health === 0 && !target._defeated) {
                  target._defeated = true; try { target.play(`${target.type||'boss'}-idle`); } catch(_) {}
                  try { this.tweens.add({ targets: target, alpha: 0, duration: 400, onComplete: () => target.destroy() }); } catch(_) {}
                  if (target === this.boss) {
                    try { this.setShowBossHP && this.setShowBossHP(false); } catch(_) {}
                    try { const hpCb = document.getElementById('devBossHP'); if (hpCb) hpCb.checked = false; } catch(_) {}
                    this.showMessage && this.showMessage((this.bossName||'Boss') + ' defeated!');
                  }
                }
                aw.hit.add(target);
                return true;
              }
              return false;
            };
            // Attempt hits on enemies and boss
            (this.enemies||[]).forEach(e => tryApply(e));
            if (this.boss) tryApply(this.boss);
          }
        }

    // Combat
  const tryAttack = (kind) => {
          if (this.isAttacking) return;
          this.isAttacking = true;
          this.alex.play(kind === 'kick' ? 'alex-kick' : 'alex-punch');
          // tiny procedural motion to sell the strike
          const tilt = kind === 'kick' ? 8 : 5;
          this.tweens.add({ targets: this.alex, angle: (this.alex.flipX?-tilt:tilt), duration: 80, yoyo: true, onComplete:()=>{ this.alex.setAngle(0); } });
          // small recoil on the player when attacking
          try {
            const recoil = (kind === 'kick') ? 3.5 : 2.5;
            const worldW = (this._bgNaturalW||800) * (this.bg?.scaleX||1);
            this.alex.x += this.alex.flipX ? recoil : -recoil;
            this.alex.x = Phaser.Math.Clamp(this.alex.x, 16, worldW - 16);
          } catch(_) {}
          // Play a short punch/kick SFX
          this.playSfx(['sfx_punch1','sfx_punch2'], 0.5, kind==='kick' ? 0.95 : 1.02);
          // Build a simple hitbox in front of Alex (larger for reliability)
          // Make hits more forgiving
          const reach = (kind === 'kick') ? 50 : 42;
          const w = (kind === 'kick') ? 34 : 30;
          const h = 28;
          const ox = this.alex.flipX ? -reach : reach;
          // Place the hitbox around chest height (a bit above the feet)
          const hitRect = new Phaser.Geom.Rectangle(this.alex.x + ox - w/2, this.alex.y - h - 6, w, h);
          // Debug draw player hitbox
          if (this.debugHitboxes && this.hitGfx) {
            try {
              this.hitGfx.lineStyle(1, 0xffff00, 1);
              this.hitGfx.strokeRect(hitRect.x, hitRect.y, hitRect.width, hitRect.height);
              const pb = this.alex.getBounds();
              this.hitGfx.lineStyle(1, 0x00ff00, 0.9);
              this.hitGfx.strokeRect(pb.x, pb.y, pb.width, pb.height);
            } catch(_) {}
          }

  const applyHit = (target, dmg, knock=10) => {
            if (!target || !target.active) return;
    // Primary: rectangle intersection against target bounds
    const tb = (typeof target.getBounds === 'function') ? target.getBounds() : null;
    const hitOk = tb ? Phaser.Geom.Intersects.RectangleToRectangle(hitRect, tb) : false;
    // Fallback: distance/lane check using centers
    const dx = Math.abs((target.x||0) - (this.alex.x + (this.alex.flipX ? -reach : reach)));
    const dy = Math.abs((this.alex.y||0) - (target.y||0));
  const nearOk = (dx <= (reach + w*0.9) && dy <= 28);
    this.debugLogs && console.log(`Player hit check: rect=${hitOk}, dx=${dx.toFixed(1)}, dy=${dy.toFixed(1)}, thresh=${(reach + w*0.9).toFixed(1)}`);
    if (hitOk || nearOk) {
      this.debugLogs && console.log(`PLAYER HIT APPLIED! Target health: ${target.health} -> ${Math.max(0, (target.health||1) - dmg)}`);
              target.health = Math.max(0, (target.health||1) - dmg);
              target.setTintFill(0xff0000);
              this.time.delayedCall(80, () => target.clearTint());
              // simple knockback
              target.x += this.alex.flipX ? -knock : knock;
              this.synth.click(1300, 0.03, 0.10);
      // brief gate to let hits resolve without separation canceling them
      this._recentHitUntil = (this.time.now||0) + 140;
              if (target.health === 0 && !target._defeated) {
                target._defeated = true; try { target.play(`${target.type||'boss'}-idle`); } catch(_) {}
                try { this.tweens.add({ targets: target, alpha: 0, duration: 400, onComplete: () => target.destroy() }); } catch(_) {}
                if (target === this.boss) {
                  try { this.setShowBossHP && this.setShowBossHP(false); } catch(_) {}
                  try { const hpCb = document.getElementById('devBossHP'); if (hpCb) hpCb.checked = false; } catch(_) {}
                  this.showMessage && this.showMessage((this.bossName||'Boss') + ' defeated!');
                }
              }
    } else {
  this.debugLogs && console.log(`Player hit MISSED: rect=${hitOk}, dx=${dx.toFixed(1)} > ${(reach + w*0.9).toFixed(1)} OR dy=${dy.toFixed(1)} > 28`);
    }
          };

          // Damage numbers
          const dmg = kind === 'kick' ? 20 : 14;
          this.enemies.forEach(e => applyHit(e, dmg, 5));
          if (this.boss) applyHit(this.boss, dmg, 8);

          // Only clear attacking when the specific attack animation completes
          const ev = `animationcomplete-${kind === 'kick' ? 'alex-kick' : 'alex-punch'}`;
          this.alex.once(ev, () => { this.isAttacking = false; this.alex.setAngle(0); });

          // Open an active attack window to catch movement during the swing
          const nowTs = this.time.now || 0;
          const windup = 24; // even shorter windup
          const active = 320; // even longer active window for easier timing
          this._attackWindow = {
            kind, reach, w, h,
            startAt: nowTs + windup,
            until: nowTs + windup + active,
            hit: new Set()
          };
        };

  if (Phaser.Input.Keyboard.JustDown(this.keys.A)) { this.runState.isRunning=false; tryAttack('punch'); }
  if (Phaser.Input.Keyboard.JustDown(this.keys.S)) { this.runState.isRunning=false; tryAttack('kick'); }
        
    // Keep Alex inside world bounds
  const displayWNow = this._bgNaturalW * this.bg.scaleX;
  this.alex.x = Phaser.Math.Clamp(this.alex.x, 16, displayWNow - 16);
        
  // ... (resize listener moved to create())
        
        // Single-enemy chase + attack AI
        this.debugLogs && console.log(`Update loop running. Enemies count: ${this.enemies.length}, Boss: ${this.boss ? 'exists' : 'null'}`);
        const hurtPlayer = (dmg, knock=8, dir=1) => {
          this.debugLogs && console.log(`hurtPlayer called: dmg=${dmg}, godMode=${this.godMode}, invulUntil=${this.playerInvulUntil}, currentTime=${time}`);
          if (this.godMode) return; // ignore damage in God Mode
          const nowMs = time;
          if (nowMs < this.playerInvulUntil) return; // i-frames
          this.alex.health = Math.max(0, (this.alex.health||0) - dmg);
          const INV = 700; // slightly longer i-frames to reduce shake
          this.playerInvulUntil = nowMs + INV;
          this.alex.setTintFill(0xffff77);
          this.time.delayedCall(120, () => this.alex.clearTint());
          // knockback along X and tiny vertical wobble
          this.alex.x += (dir<0?-1:1) * knock;
          // tiny auto-step down the lane to avoid overlapping lock
          this.alexBaseY = Phaser.Math.Clamp(this.alexBaseY + 1, this.baseYMin, this.baseYMax);
          this.cameras.main.shake(90, 0.004);
          this.synth.click(900, 0.04, 0.12);
          if (this.alex.health === 0) {
            // Auto-respawn with blinking invulnerability (classic style)
            this.showMessage('You were knocked out! Respawning...');
            try {
              const respawn = () => {
                // Restore position and health
                const { height:ch } = this.scale;
                const worldW = (this._bgNaturalW||800) * (this.bg?.scaleX||1);
                this.alex.health = 100;
                this.alexBaseY = this.baseYMax;
                this.alexJumpZ = 0; this.alexVy = 0;
                this.alex.x = Phaser.Math.Clamp((this.cameras.main.scrollX||0) + 120, 16, worldW - 16);
                this.alex.y = Math.round(this.alexBaseY);
                // Set longer i-frames and blink
                const now2 = this.time.now || (nowMs+1);
                const INV_MS = 2000;
                this.playerInvulUntil = now2 + INV_MS;
                try { this.tweens.add({ targets: this.alex, alpha: 0.25, yoyo: true, repeat: Math.floor(INV_MS/120), duration: 60 }); } catch(_) {}
                this.showMessage('Back up! (invulnerable)');
              };
              this.time.delayedCall(450, respawn);
            } catch(_) {}
          }
        };
        this.enemies.forEach(enemy => {
          if (!enemy || enemy._defeated) return;
          // face the player and chase
          const dx = this.alex.x - enemy.x;
          const dy = (this.alexBaseY - enemy.y);
          enemy.setFlipX(dx < 0);
          const alignedY = Math.abs(dy) <= 12; // lane alignment
          const distX = Math.abs(dx);
          const reach = enemy.attackReach;
          this.debugLogs && console.log(`Enemy AI: dx=${dx.toFixed(1)}, distX=${distX.toFixed(1)}, dy=${dy.toFixed(1)}, alignedY=${alignedY}, reach=${reach}, attackCooldown=${enemy.attackCooldown}, time=${time}`);
          // move towards player until in range
          if (distX > reach + 2 || !alignedY) {
            enemy.x += Math.sign(dx) * enemy.speed;
            // drift vertically to align lanes
            if (!alignedY) enemy.y += Math.sign(this.alexBaseY - enemy.y) * 0.6;
            if (enemy.anims.currentAnim?.key !== `${enemy.type}-walk`) enemy.play(`${enemy.type}-walk`);
          } else {
            if (enemy.anims.currentAnim?.key !== `${enemy.type}-idle`) enemy.play(`${enemy.type}-idle`);
            // attempt attack if cooldown over
            if (time >= (enemy.attackCooldown||0)) {
              // attack hitbox in front of enemy
              const w = enemy.attackWidth, h = enemy.attackHeight;
              const ox = enemy.flipX ? -reach : reach;
              const hitRect = new Phaser.Geom.Rectangle(enemy.x + ox - w/2, enemy.y - h - 6, w, h);
              if (this.debugHitboxes && this.hitGfx) {
                try {
                  this.hitGfx.lineStyle(1, 0xff4444, 1);
                  this.hitGfx.strokeRect(hitRect.x, hitRect.y, hitRect.width, hitRect.height);
                  const pb2 = this.alex.getBounds();
                  this.hitGfx.lineStyle(1, 0x00ff00, 0.8);
                  this.hitGfx.strokeRect(pb2.x, pb2.y, pb2.width, pb2.height);
                } catch(_) {}
              }
              const pb = this.alex.getBounds();
              this.debugLogs && console.log(`Enemy attack check: hitRect=${hitRect.x.toFixed(1)},${hitRect.y.toFixed(1)},${hitRect.width}x${hitRect.height} vs player=${pb.x.toFixed(1)},${pb.y.toFixed(1)},${pb.width}x${pb.height}`);
              if (Phaser.Geom.Intersects.RectangleToRectangle(hitRect, pb)) {
                this.debugLogs && console.log(`ENEMY HIT APPLIED! Player health: ${this.alex.health} -> ${Math.max(0, (this.alex.health||0) - 10)}`);
                hurtPlayer(10, 10, enemy.flipX?-1:1);
              } else {
                this.debugLogs && console.log(`Enemy hit MISSED`);
              }
              enemy.attackCooldown = time + enemy.attackCadence;
            }
          }
        });
        // Boss AI (Miller) – same simple chase/attack loop
        if (this.boss && !this.boss._defeated) {
          const b = this.boss;
          const dx = this.alex.x - b.x;
          const dy = (this.alexBaseY - b.y);
          const alignedY = Math.abs(dy) <= 12;
          const distX = Math.abs(dx);
          const reach = b.attackReach || 28;
          this.debugLogs && console.log(`Boss AI: dx=${dx.toFixed(1)}, distX=${distX.toFixed(1)}, dy=${dy.toFixed(1)}, alignedY=${alignedY}, reach=${reach}, attackCooldown=${b.attackCooldown}, time=${time}`);
          try { b.setFlipX && b.setFlipX(dx < 0); } catch(_) {}
          if (distX > reach + 2 || !alignedY) {
            this.debugLogs && console.log(`Boss moving towards player: distX=${distX.toFixed(1)} > ${reach + 2} OR not aligned`);
            b.x += Math.sign(dx) * (b.speed || 0.8);
            if (!alignedY) b.y += Math.sign(this.alexBaseY - b.y) * 0.6;
            try { if (b.anims?.currentAnim?.key !== `${b.type}-walk`) b.play && b.play(`${b.type}-walk`); } catch(_) {}
          } else {
            this.debugLogs && console.log(`Boss in attack range! distX=${distX.toFixed(1)} <= ${reach + 2}, aligned=${alignedY}`);
            try { if (b.anims?.currentAnim?.key !== `${b.type}-idle`) b.play && b.play(`${b.type}-idle`); } catch(_) {}
            // Immediate attack check with cooldown (simple and reliable)
            this.debugLogs && console.log(`Boss attack cooldown check: time=${time} >= attackCooldown=${b.attackCooldown}`);
            if (time >= (b.attackCooldown||0)) {
              this.debugLogs && console.log(`Boss attempting attack!`);
              try { b.play && b.play(`${b.type}-attack`); } catch(_) {}
              const w = b.attackWidth ? Math.max(22, b.attackWidth) : 60;
              const h = b.attackHeight ? Math.max(18, b.attackHeight) : 40;
              const ox = (b.flipX ? -1 : 1) * (reach * 0.9);
              const bhit = new Phaser.Geom.Rectangle(b.x + ox - w/2, b.y - h - 6, w, h);
              const dx2 = Math.abs(this.alex.x - (b.x + (b.flipX ? -reach : reach)));
              const dy2 = Math.abs(this.alex.y - b.y);
              if (this.debugHitboxes && this.hitGfx) {
                try {
                  // Boss attack box in purple to distinguish from boss body (magenta) and player attack (yellow)
                  this.hitGfx.lineStyle(1, 0x9900ff, 1);
                  this.hitGfx.strokeRect(bhit.x, bhit.y, bhit.width, bhit.height);
                  const pb3 = this.alex.getBounds();
                  this.hitGfx.lineStyle(1, 0x00ff00, 0.8);
                  this.hitGfx.strokeRect(pb3.x, pb3.y, pb3.width, pb3.height);
                } catch(_) {}
              }
              this.debugLogs && console.log(`Boss hit check: dx2=${dx2.toFixed(1)}, dy2=${dy2.toFixed(1)}, reach+w*0.6=${(reach + w*0.6).toFixed(1)}`);
              if (dx2 <= (reach + w*0.75) && dy2 <= 24) {
                this.debugLogs && console.log(`BOSS HIT APPLIED! Player health: ${this.alex.health} -> ${Math.max(0, (this.alex.health||0) - 14)}`);
                hurtPlayer(14, 16, b.flipX?-1:1);
                b.attackCooldown = time + (b.attackCadence || 900);
                this._recentHitUntil = (this.time.now||0) + 140;
              } else {
                this.debugLogs && console.log(`Boss hit MISSED: dx2=${dx2.toFixed(1)} > ${(reach + w*0.75).toFixed(1)} OR dy2=${dy2.toFixed(1)} > 24`);
              }
            }
          }
        }

        // Soft separation: never push the player; only nudge NPCs away to resolve overlap
        const separate = (a, b, minGap=6) => {
          if (!a || !b || !a.active || !b.active) return;
          // allow brief window after a hit where we don't separate (to avoid canceling hits)
          if ((this.time.now||0) < (this._recentHitUntil||0)) return;
          const ab = a.getBounds(); const bb = b.getBounds();
          if (!Phaser.Geom.Intersects.RectangleToRectangle(ab, bb)) return;
          const overlapX = Math.min(ab.right, bb.right) - Math.max(ab.left, bb.left);
          if (overlapX <= 0) return;
          const centerA = ab.centerX; const centerB = bb.centerX;
          const dir = (centerA < centerB) ? -1 : 1; // enemy on right => dir = -1
          const shift = Math.min(minGap, (overlapX/2) + 0.5);
          // Only move the non-player entity away from Alex to avoid involuntary drift
          // In our calls, 'a' is Alex and 'b' is the NPC (enemy or boss)
          try { b.x -= dir * shift; } catch(_) {}
        };
    this.enemies.forEach(e => separate(this.alex, e, 5));
    if (this.boss) separate(this.alex, this.boss, 6);
        
        // Update HUD elements
        document.getElementById('health').innerHTML = this.alex.health;
  document.getElementById('money').innerHTML = Number(this.alex.money||0).toFixed(2);
      }
    }
    
    // Simple overlay scene that pauses the game and listens for resume/mute
    class PauseOverlay extends Phaser.Scene {
      constructor(){ super({ key: 'PauseOverlay' }); }
      create(){
        const makeUi = () => {
          const w = this.scale.width, h = this.scale.height;
          if (this.maskRect) this.maskRect.destroy();
          if (this.label) this.label.destroy();
          this.maskRect = this.add.rectangle(0, 0, w, h, 0x000000, 0.55).setOrigin(0,0).setDepth(10000);
          this.label = this.add.text(w/2, h/2, 'Paused\nESC or P: Resume\nM: Mute/Unmute Music', {
            fontFamily: 'monospace', fontSize: '28px', color: '#ffff00', align: 'center', stroke:'#000', strokeThickness: 6
          }).setOrigin(0.5).setDepth(10001);
        };
        makeUi();
        this.scale.on('resize', makeUi, this);
        const KC = Phaser.Input.Keyboard.KeyCodes;
        this.keys = {
          esc: this.input.keyboard.addKey(KC.ESC),
          p: this.input.keyboard.addKey(KC.P),
          m: this.input.keyboard.addKey(KC.M)
        };
        const resume = () => { try { this.scene.stop(); this.scene.resume('BadenCityRansomGame'); } catch(_) {} };
        this.input.keyboard.on('keydown', (ev) => {
          if (ev.code === 'Escape' || ev.code === 'KeyP') { resume(); }
          else if (ev.code === 'KeyM') {
            try { const gs = this.scene.get('BadenCityRansomGame'); gs.toggleMusicMute && gs.toggleMusicMute(); } catch(_) {}
          }
        });
        // Also allow pointer click to resume for convenience
        this.input.once('pointerdown', resume);
      }
      shutdown(){ this.scale.off('resize', undefined, this); }
      destroy(){ this.scale && this.scale.off('resize', undefined, this); }
    }
    
    // Game configuration with adjusted canvas for bigger UI bars
    const config = {
      type: Phaser.AUTO,
      width: 800,
      height: 480, // 80% of a 600 reference height
      parent: 'canvasWrap',
      backgroundColor: '#000000',
  resolution: 1,
  scene: [TitleScene, BadenCityRansomGame, PauseOverlay],
      render: {
        pixelArt: true,
        antialias: false,
        roundPixels: true
      },
      scale: {
        mode: Phaser.Scale.RESIZE,
        autoCenter: Phaser.Scale.NO_CENTER,
        parent: 'canvasWrap'
      }
    };
    
  console.log('Starting authentic Baden City Ransom...');
    const game = new Phaser.Game(config);
  // Expose helpers for Dev UI
  window._BCR = { game, gs: () => { try { return game.scene.getScene('BadenCityRansomGame'); } catch(_) { return null; } } };
    
    game.events.on('ready', () => {
      console.log('🎮 BADEN CITY RANSOM IS READY TO PLAY!');
    });
    // Wire Dev UI controls
    (function(){
      const btn = document.getElementById('devBtn');
      const panel = document.getElementById('devPanel');
      const close = document.getElementById('devClose');
    const god = document.getElementById('devGod');
  const boss = document.getElementById('devBoss');
  const hitb = document.getElementById('devHit');
  const vrb = document.getElementById('devVerbose');
  const bossHp = document.getElementById('devBossHP');
      if (!btn || !panel) return;
      const gs = () => (window._BCR && window._BCR.gs) ? window._BCR.gs() : null;
      btn.addEventListener('click', () => {
        const show = panel.style.display !== 'block';
        panel.style.display = show ? 'block' : 'none';
        btn.setAttribute('aria-expanded', String(show));
      });
      close && close.addEventListener('click', () => {
        panel.style.display = 'none';
        btn.setAttribute('aria-expanded', 'false');
      });
  god && god.addEventListener('change', () => { const s = gs(); if (s && s.setGodMode) s.setGodMode(god.checked); });
  hitb && hitb.addEventListener('change', () => { const s = gs(); if (s && s.setHitboxDebug) s.setHitboxDebug(hitb.checked); });
  vrb && vrb.addEventListener('change', () => { const s = gs(); if (s && s.setVerboseLogs) s.setVerboseLogs(vrb.checked); });
  bossHp && bossHp.addEventListener('change', () => { const s = gs(); if (s && s.setShowBossHP) s.setShowBossHP(bossHp.checked); });
  boss && boss.addEventListener('change', () => { const s = gs(); if (!s) return; if (boss.checked) { s.spawnBossNearPlayer && s.spawnBossNearPlayer(); s.showMessage && s.showMessage('Spawn request sent.'); } else { s.despawnBoss && s.despawnBoss(); s.showMessage && s.showMessage('Despawn request sent.'); } });
      // Initialize boss checkbox if spawned by default
      setTimeout(() => { const s = gs(); if (s && s.boss) { if (boss) boss.checked = true; } }, 200);
    })();
  })();
  </script>
  <script>
    // Catch unexpected runtime errors early and surface them in the dialogue bar
    (function(){
      const report = (msg) => { const d = document.getElementById('dialogue-text'); if (d) d.textContent = String(msg); };
      window.addEventListener('error', (e) => {
        const parts = [
          'Error:', e?.message,
          e?.filename ? `@ ${e.filename}` : '',
          (e?.lineno||e?.colno) ? `:${e.lineno||0}:${e.colno||0}` : ''
        ].filter(Boolean);
        report(parts.join(' '));
        if (e?.error?.stack) console.error(e.error.stack);
      });
      window.addEventListener('unhandledrejection', (e) => {
        const reason = e?.reason;
        report(`Unhandled: ${reason?.message || reason || 'unknown'}`);
        if (reason?.stack) console.error(reason.stack);
      });
    })();
  </script>
</body>
</html>
